"""Track module — closed-loop racing circuit with walls, checkpoints, and spawn point.

The track is defined by centerline points in the config. Inner and outer walls
are generated by offsetting the centerline by +/- track_width/2 along smoothed
normals. This module is rendering-agnostic: the Track class works without
importing arcade. A build_shape_list() method imports arcade locally to create
efficient batched geometry for rendering.
"""

from __future__ import annotations

import math
from dataclasses import dataclass, field
from typing import Any

import numpy as np


@dataclass
class Track:
    """A closed-loop racing track defined by centerline points.

    The track consists of inner and outer wall polygons offset from the
    centerline, checkpoint line segments across the road, and a spawn point.

    Attributes:
        centerline: Ordered (N, 2) array of centerline points forming a closed loop.
        track_width: Width of the drivable road surface in pixels.
        inner_walls: List of (x, y) tuples defining the inner wall polygon.
        outer_walls: List of (x, y) tuples defining the outer wall polygon.
        checkpoint_indices: Config indices where checkpoints are placed.
        total_laps: Number of laps to complete a race.
        road_color: RGB tuple for the road surface.
        wall_color: RGB tuple for the wall lines.
    """

    centerline: np.ndarray
    track_width: float
    point_widths: list[float] = field(default_factory=list)  # per-point road widths
    inner_walls: list[tuple[float, float]] = field(default_factory=list)
    outer_walls: list[tuple[float, float]] = field(default_factory=list)
    checkpoint_indices: list[int] = field(default_factory=list)
    total_laps: int = 3
    spawn_forward_offset: float = 0.0
    road_color: tuple[int, int, int] = (60, 60, 60)
    wall_color: tuple[int, int, int] = (200, 200, 200)
    background_color: tuple[int, int, int] = (30, 30, 30)

    @classmethod
    def from_config(cls, config: dict[str, Any]) -> Track:
        """Create a Track from a parsed YAML config dictionary.

        Args:
            config: Full game config dict (top-level keys: track, colors, etc.).

        Returns:
            A fully constructed Track with walls and checkpoints computed.
        """
        track_cfg = config["track"]
        colors_cfg = config["colors"]

        centerline_raw = track_cfg["centerline_points"]
        centerline = np.array(centerline_raw, dtype=np.float64)
        track_width = float(track_cfg["track_width"])
        checkpoint_indices = list(track_cfg["checkpoint_indices"])
        total_laps = int(track_cfg.get("total_laps", 3))
        spawn_forward_offset = float(track_cfg.get("spawn_forward_offset", 0.0))

        # Per-point widths: if provided, use them; otherwise replicate the global track_width.
        n_points = len(centerline_raw)
        raw_widths = track_cfg.get("point_widths")
        if raw_widths and len(raw_widths) == n_points:
            point_widths = [float(w) for w in raw_widths]
        else:
            point_widths = [track_width] * n_points

        road_color = tuple(colors_cfg["road_color"])
        wall_color = tuple(colors_cfg["wall_color"])
        background_color = tuple(colors_cfg["background_color"])

        track = cls(
            centerline=centerline,
            track_width=track_width,
            point_widths=point_widths,
            checkpoint_indices=checkpoint_indices,
            total_laps=total_laps,
            spawn_forward_offset=spawn_forward_offset,
            road_color=road_color,
            wall_color=wall_color,
            background_color=background_color,
        )
        track._compute_walls()
        return track

    def _compute_walls(self) -> None:
        """Compute inner and outer wall polygons by offsetting the centerline.

        Uses smoothed normals: at each point, the tangent is the average of the
        directions to the previous and next points (since the track is a closed
        loop, indices wrap around). The normal is the perpendicular to this
        averaged tangent. Offsetting along the normal by +/- track_width/2
        produces the inner and outer walls.
        """
        n = len(self.centerline)

        inner = []
        outer = []

        for i in range(n):
            prev_pt = self.centerline[(i - 1) % n]
            curr_pt = self.centerline[i]
            next_pt = self.centerline[(i + 1) % n]

            # Tangent vectors to previous and next points
            tangent_back = curr_pt - prev_pt
            tangent_fwd = next_pt - curr_pt

            # Normalize both
            len_back = np.linalg.norm(tangent_back)
            len_fwd = np.linalg.norm(tangent_fwd)

            if len_back > 0:
                tangent_back = tangent_back / len_back
            if len_fwd > 0:
                tangent_fwd = tangent_fwd / len_fwd

            # Average tangent for smooth normals at corners
            avg_tangent = tangent_back + tangent_fwd
            avg_len = np.linalg.norm(avg_tangent)
            if avg_len > 1e-8:
                avg_tangent = avg_tangent / avg_len
            else:
                # Degenerate case: use forward tangent
                avg_tangent = tangent_fwd

            # Normal: rotate tangent 90 degrees CCW → (-ty, tx)
            # For a clockwise track, this points inward
            normal = np.array([-avg_tangent[1], avg_tangent[0]])

            # Use per-point width — tight sections get extra room
            half_width = self.point_widths[i] / 2.0

            inner_pt = curr_pt + normal * half_width
            outer_pt = curr_pt - normal * half_width

            inner.append((float(inner_pt[0]), float(inner_pt[1])))
            outer.append((float(outer_pt[0]), float(outer_pt[1])))

        self.inner_walls = inner
        self.outer_walls = outer

    def get_spawn_position(self) -> tuple[float, float, float]:
        """Get the car's starting position and facing angle.

        The car spawns ahead of the first centerline point (the start/finish
        line), offset by ``spawn_forward_offset`` pixels along the track
        direction.  This prevents the car from sitting on top of the
        start/finish checkpoint at reset and getting false lap credit.

        Returns:
            (x, y, angle) where angle is in radians, 0 = east, CCW positive.
        """
        p0 = self.centerline[0]
        p1 = self.centerline[1]
        direction = p1 - p0
        angle = float(math.atan2(direction[1], direction[0]))

        # Offset forward along the track direction
        dir_len = float(np.linalg.norm(direction))
        if dir_len > 1e-8 and self.spawn_forward_offset > 0.0:
            dir_unit = direction / dir_len
            spawn = p0 + dir_unit * self.spawn_forward_offset
        else:
            spawn = p0

        return (float(spawn[0]), float(spawn[1]), angle)

    def get_wall_segments(self) -> list[tuple[tuple[float, float], tuple[float, float]]]:
        """Get all wall segments as line pairs for collision detection.

        Returns both inner and outer wall segments. Each segment connects
        adjacent points in the wall polygon, wrapping from the last point
        back to the first (closed loop).

        Returns:
            List of ((x1, y1), (x2, y2)) line segments.
        """
        segments: list[tuple[tuple[float, float], tuple[float, float]]] = []

        # Inner wall segments
        n_inner = len(self.inner_walls)
        for i in range(n_inner):
            p1 = self.inner_walls[i]
            p2 = self.inner_walls[(i + 1) % n_inner]
            segments.append((p1, p2))

        # Outer wall segments
        n_outer = len(self.outer_walls)
        for i in range(n_outer):
            p1 = self.outer_walls[i]
            p2 = self.outer_walls[(i + 1) % n_outer]
            segments.append((p1, p2))

        return segments

    def get_checkpoint_segments(self) -> list[tuple[tuple[float, float], tuple[float, float]]]:
        """Get checkpoint line segments that span across the track width.

        Each checkpoint is a line segment from the inner wall point to the
        outer wall point at the corresponding centerline index.

        Returns:
            List of ((x1, y1), (x2, y2)) checkpoint segments, ordered by
            their index in checkpoint_indices.
        """
        segments: list[tuple[tuple[float, float], tuple[float, float]]] = []
        for idx in self.checkpoint_indices:
            inner_pt = self.inner_walls[idx]
            outer_pt = self.outer_walls[idx]
            segments.append((inner_pt, outer_pt))
        return segments

    def get_track_progress(self, x: float, y: float) -> float:
        """Return how far along the centerline the given position is.

        Projects the point onto each centerline segment and returns a
        fractional index in [0, num_centerline_points).  For example, if the
        point projects halfway between centerline[3] and centerline[4], this
        returns 3.5.  Used by the RL environment to compute forward progress
        reward along the track.

        Args:
            x: World x coordinate.
            y: World y coordinate.

        Returns:
            Fractional index along the centerline (0 = start, wraps at N).
        """
        point = np.array([x, y], dtype=np.float64)
        n = len(self.centerline)

        best_progress: float = 0.0
        best_dist_sq: float = float("inf")

        for i in range(n):
            a = self.centerline[i]
            b = self.centerline[(i + 1) % n]

            ab = b - a
            ap = point - a
            ab_len_sq = float(np.dot(ab, ab))

            if ab_len_sq < 1e-12:
                t = 0.0
                dist_sq = float(np.dot(ap, ap))
            else:
                t = float(np.dot(ap, ab)) / ab_len_sq
                t = max(0.0, min(1.0, t))
                closest = a + t * ab
                diff = point - closest
                dist_sq = float(np.dot(diff, diff))

            if dist_sq < best_dist_sq:
                best_dist_sq = dist_sq
                best_progress = float(i) + t

        return best_progress

    def get_lateral_displacement(self, x: float, y: float) -> float:
        """Return the perpendicular distance from a point to the nearest centerline segment.

        Projects the point onto each centerline segment and returns the minimum
        perpendicular distance in pixels.  Used by the RL environment to penalize
        the car for straying far from the center of the road.

        Args:
            x: World x coordinate.
            y: World y coordinate.

        Returns:
            Perpendicular distance in pixels from the point to the nearest
            centerline segment.  Always >= 0.
        """
        point = np.array([x, y], dtype=np.float64)
        n = len(self.centerline)

        best_dist_sq: float = float("inf")

        for i in range(n):
            a = self.centerline[i]
            b = self.centerline[(i + 1) % n]

            ab = b - a
            ap = point - a
            ab_len_sq = float(np.dot(ab, ab))

            if ab_len_sq < 1e-12:
                dist_sq = float(np.dot(ap, ap))
            else:
                t = float(np.dot(ap, ab)) / ab_len_sq
                t = max(0.0, min(1.0, t))
                closest = a + t * ab
                diff = point - closest
                dist_sq = float(np.dot(diff, diff))

            if dist_sq < best_dist_sq:
                best_dist_sq = dist_sq

        return math.sqrt(best_dist_sq)

    def is_on_track(self, x: float, y: float) -> bool:
        """Check whether a world position is within the drivable road surface.

        Uses a distance-to-nearest-centerline-segment approach. The point is
        considered on-track if its distance to the nearest centerline segment
        is less than or equal to track_width / 2.

        Args:
            x: World x coordinate.
            y: World y coordinate.

        Returns:
            True if the point is within the track boundaries.
        """
        point = np.array([x, y], dtype=np.float64)
        n = len(self.centerline)

        for i in range(n):
            a = self.centerline[i]
            b = self.centerline[(i + 1) % n]

            # Effective half-width for this segment: average of its two endpoint widths
            seg_half_width = (self.point_widths[i] + self.point_widths[(i + 1) % n]) / 4.0
            seg_half_width_sq = seg_half_width * seg_half_width

            # Project point onto segment a-b
            ab = b - a
            ap = point - a
            ab_len_sq = float(np.dot(ab, ab))

            if ab_len_sq < 1e-12:
                dist_sq = float(np.dot(ap, ap))
            else:
                t = float(np.dot(ap, ab)) / ab_len_sq
                t = max(0.0, min(1.0, t))
                closest = a + t * ab
                diff = point - closest
                dist_sq = float(np.dot(diff, diff))

            if dist_sq <= seg_half_width_sq:
                return True

        return False

    def build_shape_list(self) -> Any:
        """Build an Arcade ShapeElementList for efficient batched track rendering.

        Imports arcade locally so the Track class can be used without a display.
        Creates:
        - A filled polygon for the road surface (using triangles between inner
          and outer walls)
        - Line strips for inner and outer walls
        - Checkpoint lines (thin, semi-transparent)

        Returns:
            An arcade.ShapeElementList ready to draw.
        """
        import arcade
        from arcade.shape_list import (
            ShapeElementList,
            create_line,
            create_line_strip,
            create_triangles_filled_with_colors,
        )

        shape_list = ShapeElementList()

        # --- Road surface ---
        # Build the road as a triangle strip between inner and outer walls.
        # Interleave inner[i], outer[i] to form quads rendered as triangle strips.
        n = len(self.inner_walls)
        road_points: list[tuple[float, float]] = []
        road_colors: list[tuple[int, int, int, int]] = []
        road_rgba = (*self.road_color, 255)

        for i in range(n):
            next_i = (i + 1) % n
            # Two triangles per quad: inner[i], outer[i], outer[next_i]
            # and inner[i], outer[next_i], inner[next_i]
            tri1 = [
                self.inner_walls[i],
                self.outer_walls[i],
                self.outer_walls[next_i],
            ]
            tri2 = [
                self.inner_walls[i],
                self.outer_walls[next_i],
                self.inner_walls[next_i],
            ]
            for tri in [tri1, tri2]:
                shape = create_triangles_filled_with_colors(
                    point_list=tri,
                    color_sequence=[road_rgba, road_rgba, road_rgba],
                )
                shape_list.append(shape)

        # --- Wall lines ---
        wall_rgba = (*self.wall_color, 255)

        # Inner wall loop
        inner_loop = list(self.inner_walls) + [self.inner_walls[0]]
        inner_shape = create_line_strip(
            point_list=inner_loop,
            color=wall_rgba,
            line_width=2,
        )
        shape_list.append(inner_shape)

        # Outer wall loop
        outer_loop = list(self.outer_walls) + [self.outer_walls[0]]
        outer_shape = create_line_strip(
            point_list=outer_loop,
            color=wall_rgba,
            line_width=2,
        )
        shape_list.append(outer_shape)

        # --- Checkpoint lines ---
        checkpoint_color = (255, 255, 0, 100)  # Semi-transparent yellow
        for seg in self.get_checkpoint_segments():
            cp_shape = create_line(
                start_x=seg[0][0],
                start_y=seg[0][1],
                end_x=seg[1][0],
                end_y=seg[1][1],
                color=checkpoint_color,
                line_width=2,
            )
            shape_list.append(cp_shape)

        return shape_list
