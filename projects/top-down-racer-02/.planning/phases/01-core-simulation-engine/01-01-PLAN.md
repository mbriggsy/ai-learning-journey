---
phase: 01-core-simulation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.ts
  - package.json
  - src/engine/types.ts
  - src/engine/constants.ts
  - src/engine/vec2.ts
  - src/engine/spline.ts
  - tests/engine/vec2.test.ts
  - tests/engine/spline.test.ts
autonomous: true
requirements:
  - MECH-09
  - MECH-14
  - MECH-15

must_haves:
  truths:
    - "Vec2 operations (add, sub, scale, dot, cross, normalize, rotate, length, lerp, distance) produce mathematically correct results"
    - "Catmull-Rom spline evaluates smooth curves through control points without cusps (centripetal alpha=0.5)"
    - "Arc-length parameterization maps uniform distances to spline parameters via lookup table + binary search"
    - "All engine code is pure TypeScript with zero external physics/math dependencies"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest test runner configuration"
      contains: "defineConfig"
    - path: "src/engine/types.ts"
      provides: "All engine interfaces and type definitions"
      exports: ["Vec2", "CarState", "Input", "SmoothedInput", "TrackState", "TimingState", "WorldState", "Surface", "CollisionResult", "Checkpoint", "ArcLengthTable", "TrackControlPoint"]
    - path: "src/engine/constants.ts"
      provides: "Physics constants and tuning parameters"
      exports: ["DT", "CAR", "TIRE", "SURFACE_GRIP", "INPUT_RATES", "WALL_FRICTION"]
    - path: "src/engine/vec2.ts"
      provides: "Pure 2D vector math functions"
      exports: ["vec2", "add", "sub", "scale", "dot", "cross", "length", "normalize", "rotate", "distance", "lerp", "lerpAngle"]
      min_lines: 60
    - path: "src/engine/spline.ts"
      provides: "Catmull-Rom spline evaluation and arc-length parameterization"
      exports: ["catmullRomPoint", "catmullRomTangent", "buildArcLengthTable", "paramAtDistance", "pointAtDistance", "tangentAtDistance"]
      min_lines: 100
    - path: "tests/engine/vec2.test.ts"
      provides: "Vec2 correctness tests"
      min_lines: 50
    - path: "tests/engine/spline.test.ts"
      provides: "Spline evaluation and arc-length tests"
      min_lines: 50
  key_links:
    - from: "src/engine/spline.ts"
      to: "src/engine/vec2.ts"
      via: "import { Vec2, add, sub, scale, length } from './vec2'"
      pattern: "import.*from.*vec2"
    - from: "src/engine/spline.ts"
      to: "src/engine/types.ts"
      via: "import { ArcLengthTable, TrackControlPoint } from './types'"
      pattern: "import.*from.*types"
---

<objective>
Set up the project testing infrastructure, define all engine type contracts, physics constants, and implement the two foundational math modules: 2D vector math and Catmull-Rom spline geometry with arc-length parameterization.

Purpose: Every subsequent plan imports from these modules. Types define the contracts that car physics, collision, and track systems build against. Vec2 is used in every calculation. Spline geometry defines the track centerline that all other systems reference.

Output: Working vitest config, complete type definitions, vec2 and spline modules with passing tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/01-CONTEXT.md
@.planning/phases/01-core-simulation-engine/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Vitest + Define Engine Types and Constants</name>
  <files>vitest.config.ts, package.json, src/engine/types.ts, src/engine/constants.ts</files>
  <action>
1. Create `vitest.config.ts` at project root:
   - Import `defineConfig` from `vitest/config`
   - Set `test.include` to `['tests/**/*.test.ts']`
   - Set `test.globals` to false (explicit imports)
   - Enable TypeScript path resolution matching tsconfig

2. Update `package.json` scripts:
   - Change `"test"` from the placeholder to `"vitest run"`
   - Add `"test:watch"` as `"vitest"`
   - Add `"test:verbose"` as `"vitest run --reporter=verbose"`

3. Create `src/engine/types.ts` with ALL engine interfaces (these are the contracts for the entire phase):

   ```typescript
   // Vec2 - plain object, readonly, no class
   export interface Vec2 {
     readonly x: number;
     readonly y: number;
   }

   // Surface enum
   export const enum Surface {
     Road = 0,
     Runoff = 1,
   }

   // Raw input from keyboard/AI
   export interface Input {
     steer: number;    // -1.0 to +1.0
     throttle: number; // 0.0 to 1.0
     brake: number;    // 0.0 to 1.0
   }

   // Smoothed input with computed steer angle
   export interface SmoothedInput {
     steer: number;
     throttle: number;
     brake: number;
     steerAngle: number; // radians, computed from steer + speed
   }

   // Car state (immutable snapshot per tick)
   export interface CarState {
     position: Vec2;
     velocity: Vec2;
     heading: number;       // radians
     yawRate: number;       // rad/s
     speed: number;         // scalar speed (length of velocity)
     prevInput: SmoothedInput;
     surface: Surface;
     accelLongitudinal: number; // for weight transfer calc next tick
   }

   // Track control point (centerline position + width)
   export interface TrackControlPoint {
     position: Vec2;
     width: number;  // half-width from centerline to edge
   }

   // Arc-length lookup table
   export interface ArcLengthTable {
     lengths: readonly number[];  // cumulative arc length at each sample
     params: readonly number[];   // corresponding spline parameter (0 to N)
     totalLength: number;
   }

   // Checkpoint gate
   export interface Checkpoint {
     left: Vec2;
     right: Vec2;
     center: Vec2;
     direction: Vec2;  // unit vector along spline at this gate
     arcLength: number; // distance along track
   }

   // Built track (immutable after creation)
   export interface TrackState {
     controlPoints: readonly TrackControlPoint[];
     innerBoundary: readonly Vec2[];   // polyline
     outerBoundary: readonly Vec2[];   // polyline
     checkpoints: readonly Checkpoint[];
     arcLengthTable: ArcLengthTable;
     totalLength: number;
     startPosition: Vec2;
     startHeading: number;
   }

   // Collision result
   export interface CollisionResult {
     collided: boolean;
     penetration: number;
     normal: Vec2;        // points away from wall, into track
     contactPoint: Vec2;
   }

   // Timing state
   export interface TimingState {
     currentLapTicks: number;
     bestLapTicks: number;     // -1 if no completed lap
     currentLap: number;       // 1-indexed
     lastCheckpointIndex: number;
     lapComplete: boolean;     // true on the tick a lap finishes
   }

   // Full world state
   export interface WorldState {
     tick: number;
     car: CarState;
     track: TrackState;       // immutable reference
     timing: TimingState;
   }
   ```

   Note: Use `const enum` for Surface so it inlines to numbers (performance for headless). Add JSDoc comments to each interface explaining its role. Keep Vec2 as a plain interface (not a class) per research anti-patterns.

4. Create `src/engine/constants.ts` with all tuning parameters:

   ```typescript
   export const DT = 1 / 60; // Fixed timestep (MECH-14)

   export const CAR = {
     mass: 1200,              // kg
     weight: 1200 * 9.81,     // N
     wheelbase: 2.6,          // meters (game units)
     cgToFront: 1.2,          // CG to front axle
     cgToRear: 1.4,           // CG to rear axle (slightly rearward for oversteer tendency)
     cgHeight: 0.5,           // CG height (for weight transfer)
     length: 4.0,             // car length in game units
     width: 2.0,              // car width in game units
     maxEngineForce: 8000,    // N — tune for ~4-5 sec to top speed
     maxBrakeForce: 12000,    // N — stronger than engine for meaningful braking
     dragCoefficient: 0.4,    // aerodynamic drag
     rollingResistance: 30,   // rolling resistance factor
     maxSpeed: 200,           // units/sec cap (per CONTEXT: 150-200)
   } as const;

   export const TIRE = {
     B: 8.0,                  // stiffness factor (how quickly grip builds)
     C: 1.4,                  // shape factor (peak width)
     mu: 1.0,                 // base friction coefficient
   } as const;

   export const SURFACE_GRIP: Record<number, number> = {
     0: 1.0,   // Surface.Road
     1: 0.5,   // Surface.Runoff (~50% per CONTEXT.md)
   };

   export const INPUT_RATES = {
     steer: 4.0,              // steering response rate
     throttle: 6.0,           // throttle response rate
     brake: 10.0,             // brake response (fastest)
   } as const;

   export const WALL_FRICTION = 0.3; // tangential friction during wall slide

   export const STEER = {
     maxAngle: 0.6,           // radians (~34 degrees max front wheel angle)
     speedFactor: 0.006,      // speed reduction coefficient for MECH-06
   } as const;
   ```

   All constants should be `as const` for literal types. Document each constant with its role and which requirement it satisfies. These values are starting points for tuning — the structure matters more than exact numbers.
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run --reporter=verbose 2>&1 | head -20</automated>
  </verify>
  <done>
  - vitest.config.ts exists and vitest runs without config errors
  - package.json has test/test:watch/test:verbose scripts
  - types.ts exports all engine interfaces (Vec2, CarState, Input, SmoothedInput, TrackState, TimingState, WorldState, Surface, CollisionResult, Checkpoint, ArcLengthTable, TrackControlPoint)
  - constants.ts exports DT, CAR, TIRE, SURFACE_GRIP, INPUT_RATES, WALL_FRICTION, STEER
  - TypeScript compiles with no errors (npx tsc --noEmit)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Vec2 Module with Tests</name>
  <files>src/engine/vec2.ts, tests/engine/vec2.test.ts</files>
  <action>
1. Create `src/engine/vec2.ts` with pure functions operating on Vec2 interface (imported from types.ts):

   Required functions (all pure, no mutation):
   - `vec2(x, y)` — factory
   - `add(a, b)` — vector addition
   - `sub(a, b)` — vector subtraction
   - `scale(v, s)` — scalar multiply
   - `dot(a, b)` — dot product
   - `cross(a, b)` — 2D cross product (returns scalar z-component)
   - `length(v)` — magnitude
   - `lengthSq(v)` — squared magnitude (avoid sqrt when possible)
   - `normalize(v)` — unit vector (return zero vector if length < 1e-10)
   - `rotate(v, angle)` — rotate by radians
   - `distance(a, b)` — distance between points
   - `distanceSq(a, b)` — squared distance
   - `lerp(a, b, t)` — linear interpolation
   - `lerpAngle(a, b, t)` — angle interpolation handling wrapping (-PI to PI)
   - `perpCW(v)` — perpendicular clockwise { x: v.y, y: -v.x }
   - `perpCCW(v)` — perpendicular counter-clockwise { x: -v.y, y: v.x }
   - `negate(v)` — negate both components
   - `fromAngle(angle)` — unit vector from angle in radians

   Implementation notes:
   - Do NOT use classes. Plain objects only.
   - All functions return new objects (never mutate).
   - Use `Math.cos`, `Math.sin`, `Math.sqrt`, `Math.atan2` (these are deterministic).
   - `lerpAngle` must handle wrapping: compute shortest angular distance, then interpolate.
   - Export the Vec2 type re-export from types.ts for convenience.

2. Create `tests/engine/vec2.test.ts` with comprehensive tests:

   Test cases must include:
   - `vec2(3, 4)` produces `{ x: 3, y: 4 }`
   - `add({1,2}, {3,4})` = `{4,6}`
   - `sub({5,7}, {2,3})` = `{3,4}`
   - `scale({3,4}, 2)` = `{6,8}`
   - `dot({1,0}, {0,1})` = 0 (perpendicular)
   - `dot({1,0}, {1,0})` = 1 (parallel)
   - `cross({1,0}, {0,1})` = 1
   - `cross({0,1}, {1,0})` = -1
   - `length({3,4})` = 5
   - `lengthSq({3,4})` = 25
   - `normalize({3,4})` = `{0.6, 0.8}`
   - `normalize({0,0})` = `{0,0}` (zero vector guard)
   - `rotate({1,0}, PI/2)` approximately `{0,1}`
   - `rotate({1,0}, PI)` approximately `{-1,0}`
   - `distance({0,0}, {3,4})` = 5
   - `lerp({0,0}, {10,10}, 0.5)` = `{5,5}`
   - `lerpAngle(0, PI, 0.5)` = `PI/2`
   - `lerpAngle(-0.1, 0.1, 0.5)` = 0 (near zero crossing)
   - `lerpAngle(PI - 0.1, -PI + 0.1, 0.5)` approximately `PI` (wrapping around PI)
   - `perpCW({1,0})` = `{0,-1}`
   - `perpCCW({1,0})` = `{0,1}`
   - `fromAngle(0)` = `{1,0}`, `fromAngle(PI/2)` approximately `{0,1}`

   Use `toBeCloseTo` for floating-point comparisons (5 decimal places). Group tests by function with `describe` blocks.
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run tests/engine/vec2.test.ts --reporter=verbose</automated>
  </verify>
  <done>
  - All vec2 tests pass
  - Every exported function has at least 2 test cases
  - Zero vector normalize guard works (returns {0,0})
  - lerpAngle correctly handles wrapping around PI/-PI
  - No mutation of input vectors (functions are pure)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Spline Module with Tests</name>
  <files>src/engine/spline.ts, tests/engine/spline.test.ts</files>
  <action>
1. Create `src/engine/spline.ts` implementing centripetal Catmull-Rom spline evaluation and arc-length parameterization:

   Required functions:
   - `catmullRomPoint(p0, p1, p2, p3, t)` — Evaluate centripetal Catmull-Rom spline at parameter t (0-1), interpolating between p1 and p2. Use alpha=0.5 (centripetal) to avoid cusps. Implementation per research code example: compute knot intervals, tangents, scale, Hermite basis.
   - `catmullRomTangent(p0, p1, p2, p3, t)` — First derivative (tangent vector) at parameter t. Needed for perpendicular checkpoint gates and track direction. Compute by differentiating the Hermite basis functions.
   - `buildArcLengthTable(controlPoints, samplesPerSegment)` — Build cumulative arc-length lookup table for a CLOSED spline loop. Iterate over all segments (wrapping indices for closed loop), sample at `samplesPerSegment` intervals, accumulate distances. Return `ArcLengthTable` with lengths[], params[], and totalLength.
   - `paramAtDistance(table, distance)` — Binary search the arc-length table to find the spline parameter at a given arc-length distance. Handle wrapping (distance > totalLength wraps around). This is the core of uniform parameterization.
   - `pointAtDistance(controlPoints, table, distance)` — Convenience: get a point on the spline at a given arc-length distance. Converts distance → param via `paramAtDistance`, then evaluates the spline.
   - `tangentAtDistance(controlPoints, table, distance)` — Convenience: get the tangent at a given arc-length distance.

   Implementation notes:
   - The spline is ALWAYS a closed loop (for track geometry). Indices wrap: `controlPoints[(i + n) % n]`.
   - Use 20 samples per segment as the default for `samplesPerSegment`.
   - The `catmullRomPoint` function must use centripetal parameterization (alpha=0.5) per research. Do NOT use uniform parameterization (alpha=0) — it produces cusps at uneven control point spacing.
   - Import Vec2 operations from vec2.ts. Import types from types.ts.

2. Create `tests/engine/spline.test.ts` with tests:

   Test cases:
   - **Interpolation:** For a square of 4 control points, `catmullRomPoint(p0,p1,p2,p3, 0)` = p1, `catmullRomPoint(p0,p1,p2,p3, 1)` = p2 (endpoints match)
   - **Midpoint:** For evenly spaced collinear points, midpoint should be between p1 and p2
   - **Smoothness:** For a curved arrangement, intermediate points should NOT lie on straight line between p1 and p2 (verifies curve is curved)
   - **Tangent at endpoints:** Tangent at t=0 should point roughly from p0 toward p2 (the Catmull-Rom tangent property)
   - **Arc-length table:** For a circle-like arrangement of control points, totalLength should approximate the circle circumference
   - **Arc-length uniformity:** Points sampled at equal arc-length intervals should be approximately equally spaced (distance between consecutive points is roughly constant). This is the key test — the whole point of arc-length parameterization.
   - **paramAtDistance wrapping:** `paramAtDistance(table, totalLength + d)` should equal `paramAtDistance(table, d)` (wraps correctly)
   - **Closed loop:** pointAtDistance at distance 0 and distance totalLength should return the same point
   - **Tangent direction:** Tangent should be roughly perpendicular to the radius at each point for a circular arrangement
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run tests/engine/spline.test.ts --reporter=verbose</automated>
  </verify>
  <done>
  - All spline tests pass
  - Catmull-Rom interpolation hits control points at t=0 and t=1
  - Arc-length parameterization produces uniformly spaced points
  - Closed-loop wrapping works correctly (distance 0 = distance totalLength)
  - No cusps in output (centripetal parameterization)
  - Full test suite still passes: `pnpm test` exits 0
  </done>
</task>

</tasks>

<verification>
Run the full test suite to verify all foundation modules work together:

```bash
cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02
pnpm test
npx tsc --noEmit  # TypeScript compilation check
```

All tests must pass. TypeScript must compile with zero errors in strict mode.
</verification>

<success_criteria>
- vitest.config.ts exists and `pnpm test` runs successfully
- types.ts exports all engine interfaces needed by subsequent plans
- constants.ts exports all tuning parameters
- vec2.ts has 15+ pure functions, all tested
- spline.ts evaluates centripetal Catmull-Rom and provides arc-length parameterization, all tested
- Zero external math/physics dependencies in src/engine/
- TypeScript strict mode compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-simulation-engine/01-01-SUMMARY.md`
</output>
