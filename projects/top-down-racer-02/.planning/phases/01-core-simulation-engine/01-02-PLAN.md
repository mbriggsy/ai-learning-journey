---
phase: 01-core-simulation-engine
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/engine/track.ts
  - src/engine/collision.ts
  - src/tracks/track01.ts
  - tests/engine/track.test.ts
  - tests/engine/collision.test.ts
autonomous: true
requirements:
  - MECH-07
  - MECH-08
  - MECH-09
  - TRK-01

must_haves:
  truths:
    - "Track builder generates closed inner/outer boundary polylines from spline centerline + per-control-point width"
    - "Surface detection correctly identifies road vs runoff based on distance from track boundaries"
    - "Wall collision detects car penetration into boundary and resolves by sliding along wall with speed penalty proportional to impact angle"
    - "Wall contact rotates car nose to align with wall surface"
    - "Glancing wall contact costs ~15-25% speed; head-on impact nearly stops the car"
    - "Primary track has hairpins, sweepers, and chicanes forming a closed loop"
  artifacts:
    - path: "src/engine/track.ts"
      provides: "Track builder: spline control points to boundary polylines, surface detection"
      exports: ["buildTrack", "getSurface", "distanceToTrackCenter", "nearestBoundaryPoint"]
      min_lines: 80
    - path: "src/engine/collision.ts"
      provides: "Wall collision detection and sliding response"
      exports: ["detectWallCollision", "resolveWallCollision", "pointToSegmentDistance"]
      min_lines: 80
    - path: "src/tracks/track01.ts"
      provides: "Primary track control point data"
      exports: ["TRACK_01_CONTROL_POINTS"]
      min_lines: 30
    - path: "tests/engine/track.test.ts"
      provides: "Track builder tests"
      min_lines: 50
    - path: "tests/engine/collision.test.ts"
      provides: "Collision detection and response tests"
      min_lines: 60
  key_links:
    - from: "src/engine/track.ts"
      to: "src/engine/spline.ts"
      via: "import spline functions for centerline evaluation"
      pattern: "import.*from.*spline"
    - from: "src/engine/track.ts"
      to: "src/engine/vec2.ts"
      via: "import vec2 functions for boundary offset calculation"
      pattern: "import.*from.*vec2"
    - from: "src/engine/collision.ts"
      to: "src/engine/vec2.ts"
      via: "import vec2 for projection, dot product, normal calculation"
      pattern: "import.*from.*vec2"
    - from: "src/tracks/track01.ts"
      to: "src/engine/types.ts"
      via: "import TrackControlPoint type"
      pattern: "import.*TrackControlPoint.*from"
---

<objective>
Build the track construction pipeline and wall collision system. The track builder converts spline control points into boundary polylines and surface zones. The collision module detects car-wall contact and resolves it with a sliding response per the user's locked decisions (proportional speed penalty, nose rotation, slide-along behavior).

Purpose: The track is the arena everything else operates in. Collision detection keeps the car inside. These modules are consumed by the world step function (Plan 04).

Output: Buildable track from control point data, collision detection/response, and the primary track (TRK-01) defined.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/01-CONTEXT.md
@.planning/phases/01-core-simulation-engine/01-RESEARCH.md
@.planning/phases/01-core-simulation-engine/01-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01. Executor should use these directly. -->

From src/engine/types.ts:
```typescript
export interface Vec2 { readonly x: number; readonly y: number; }
export const enum Surface { Road = 0, Runoff = 1 }
export interface TrackControlPoint { position: Vec2; width: number; }
export interface ArcLengthTable { lengths: readonly number[]; params: readonly number[]; totalLength: number; }
export interface Checkpoint { left: Vec2; right: Vec2; center: Vec2; direction: Vec2; arcLength: number; }
export interface TrackState {
  controlPoints: readonly TrackControlPoint[];
  innerBoundary: readonly Vec2[];
  outerBoundary: readonly Vec2[];
  checkpoints: readonly Checkpoint[];
  arcLengthTable: ArcLengthTable;
  totalLength: number;
  startPosition: Vec2;
  startHeading: number;
}
export interface CollisionResult { collided: boolean; penetration: number; normal: Vec2; contactPoint: Vec2; }
export interface CarState { position: Vec2; velocity: Vec2; heading: number; yawRate: number; speed: number; /* ... */ }
```

From src/engine/vec2.ts:
```typescript
export function vec2(x: number, y: number): Vec2;
export function add(a: Vec2, b: Vec2): Vec2;
export function sub(a: Vec2, b: Vec2): Vec2;
export function scale(v: Vec2, s: number): Vec2;
export function dot(a: Vec2, b: Vec2): number;
export function cross(a: Vec2, b: Vec2): number;
export function length(v: Vec2): number;
export function normalize(v: Vec2): Vec2;
export function perpCW(v: Vec2): Vec2;
export function perpCCW(v: Vec2): Vec2;
export function distance(a: Vec2, b: Vec2): number;
export function rotate(v: Vec2, angle: number): Vec2;
export function lerpAngle(a: number, b: number, t: number): number;
```

From src/engine/spline.ts:
```typescript
export function catmullRomPoint(p0: Vec2, p1: Vec2, p2: Vec2, p3: Vec2, t: number): Vec2;
export function catmullRomTangent(p0: Vec2, p1: Vec2, p2: Vec2, p3: Vec2, t: number): Vec2;
export function buildArcLengthTable(controlPoints: Vec2[], samplesPerSegment: number): ArcLengthTable;
export function paramAtDistance(table: ArcLengthTable, distance: number): number;
export function pointAtDistance(controlPoints: Vec2[], table: ArcLengthTable, distance: number): Vec2;
export function tangentAtDistance(controlPoints: Vec2[], table: ArcLengthTable, distance: number): Vec2;
```

From src/engine/constants.ts:
```typescript
export const WALL_FRICTION = 0.3;
export const SURFACE_GRIP: Record<number, number>; // 0: 1.0 (road), 1: 0.5 (runoff)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Track Builder and Surface Detection</name>
  <files>src/engine/track.ts, src/tracks/track01.ts, tests/engine/track.test.ts</files>
  <action>
1. Create `src/engine/track.ts` with the track construction pipeline:

   **`buildTrack(controlPoints: TrackControlPoint[], checkpointCount: number): TrackState`**
   - Extract position array from control points for spline evaluation
   - Build arc-length table using `buildArcLengthTable` from spline.ts (20 samples per segment)
   - Generate inner and outer boundary polylines:
     - Sample the spline at dense intervals (~200+ points around the loop for smooth boundaries)
     - At each sample point, get the tangent direction from the spline
     - Compute perpendicular offset using `perpCW` and `perpCCW` on the normalized tangent
     - Interpolate width from control points (lerp between nearest control point widths based on arc-length position)
     - Inner boundary = centerline - perpendicular * width
     - Outer boundary = centerline + perpendicular * width
   - Generate checkpoint gates at uniform arc-length intervals:
     - For N checkpoints, spacing = totalLength / N
     - At each checkpoint position: get center point and tangent from spline
     - Gate endpoints = center +/- perpendicular * width
     - Store direction (normalized tangent) for crossing direction detection
   - Determine start position and heading from the first control point
   - Return complete TrackState

   **`getSurface(position: Vec2, track: TrackState): Surface`**
   - Find nearest boundary segment on both inner and outer boundaries
   - If car position is INSIDE both boundaries → Surface.Road
   - If car position is OUTSIDE either boundary → Surface.Runoff
   - Implementation: Check if point is between inner and outer boundaries using cross-product winding or signed distance. A simpler approach: compute distance to track centerline at the nearest arc-length position. If distance < width at that position → Road, else → Runoff.

   **`distanceToTrackCenter(position: Vec2, track: TrackState): { distance: number; arcLength: number; }`**
   - Find the nearest point on the centerline spline to the given position
   - Return the perpendicular distance and the arc-length position on track
   - This is used for surface detection and AI observations (Phase 4)
   - Implementation: Sample the arc-length table at intervals, find the closest center point, then refine with binary search in the local region

   **`nearestBoundaryPoint(position: Vec2, boundary: readonly Vec2[]): { point: Vec2; segmentIndex: number; distance: number; normal: Vec2; }`**
   - Iterate all boundary segments, find the nearest point on any segment to the given position
   - Return the closest point, segment index, distance, and outward normal
   - This is used by collision detection

   Implementation notes:
   - Boundary sampling density must be high enough that no segment is longer than ~2 units (to prevent tunneling at 200 units/sec). With 200+ samples around the loop, each segment is typically < 2 units for a ~1000 unit perimeter.
   - The track is ALWAYS a closed loop — first and last boundary points should connect.
   - Use a simple linear scan for `nearestBoundaryPoint` in this phase. Spatial hashing optimization can wait until performance profiling (Phase 4/5).

2. Create `src/tracks/track01.ts` with the primary track control points:

   Design a track with ~20-25 control points forming a closed loop with:
   - 2 hairpins (tight ~20-unit radius corners, ~180 degrees)
   - 2-3 sweeping corners (wide ~60-80 unit radius, ~90 degrees)
   - 1 chicane (S-curve, two quick direction changes)
   - 2 straights (for top speed opportunity)
   - Track width: 12-16 units (6-8 half-width), narrower at chicane (~10 units)

   The track should be centered roughly around (0,0) with extents of about 400x300 units. This gives enough room for the speed range (150-200 units/sec) to feel exciting while keeping corners reactable.

   Export as `TRACK_01_CONTROL_POINTS: TrackControlPoint[]`.

3. Create `tests/engine/track.test.ts`:

   Test cases:
   - **buildTrack produces valid boundaries:** Inner and outer boundaries have > 100 points each
   - **Boundaries are closed:** First and last points of each boundary are close together (< 1 unit)
   - **Boundary width correct:** At control point locations, distance between inner and outer boundary matches control point width
   - **Checkpoints generated:** Requested number of checkpoints are created
   - **Checkpoints are sequential:** Each checkpoint's arcLength is greater than the previous
   - **Checkpoint gates span track:** Gate width (left to right distance) approximately equals track width at that location
   - **getSurface:** Point on centerline returns Road. Point far outside boundaries returns Runoff.
   - **getSurface boundary:** Point just inside boundary is Road, just outside is Runoff
   - **Track 01 builds:** `buildTrack(TRACK_01_CONTROL_POINTS, 30)` produces a valid TrackState without errors
   - **Track 01 is closed loop:** Start and end of boundaries are connected
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run tests/engine/track.test.ts --reporter=verbose</automated>
  </verify>
  <done>
  - buildTrack generates inner/outer boundary polylines from spline control points + width
  - Boundary polylines are closed loops with dense sampling (no segment > 2 units)
  - getSurface correctly returns Road inside boundaries, Runoff outside
  - Checkpoint gates are generated at uniform arc-length intervals
  - TRACK_01_CONTROL_POINTS defines a track with hairpins, sweepers, chicanes, and straights
  - Track 01 builds successfully into a valid TrackState
  </done>
</task>

<task type="auto">
  <name>Task 2: Wall Collision Detection and Response</name>
  <files>src/engine/collision.ts, tests/engine/collision.test.ts</files>
  <action>
1. Create `src/engine/collision.ts` implementing wall detection and sliding response:

   **`pointToSegmentDistance(point: Vec2, segA: Vec2, segB: Vec2): { distance: number; nearest: Vec2; t: number; }`**
   - Standard point-to-line-segment projection
   - Project point onto the infinite line through segA→segB, clamp t to [0,1]
   - Return distance, nearest point on segment, and parameter t
   - This is the fundamental geometric primitive for collision detection

   **`detectWallCollision(position: Vec2, radius: number, track: TrackState): CollisionResult`**
   - Check car position against both inner and outer boundary polylines
   - The car is modeled as a circle with the given radius (~1.0 unit, half the car width)
   - For each boundary polyline, find the nearest segment
   - If distance < radius → collision detected
   - The normal points from the wall INTO the track (away from wall)
   - For inner boundary: normal points outward (toward track center → toward outer)
   - For outer boundary: normal points inward (toward track center → toward inner)
   - Return the CLOSEST collision if multiple exist
   - If no collision: return `{ collided: false, penetration: 0, normal: vec2(0,0), contactPoint: vec2(0,0) }`

   **`resolveWallCollision(car: CarState, collision: CollisionResult): CarState`**
   - If no collision, return car unchanged
   - Decompose velocity into normal component (into wall) and tangential component (along wall)
   - Only resolve if car is moving INTO the wall (vDotN < 0)
   - Remove the normal velocity component entirely (car absorbs the impact)
   - Apply WALL_FRICTION to tangential component (from constants.ts)
   - Speed penalty is naturally proportional to impact angle because:
     - Glancing (small angle): tangential component is large, normal is small → small speed loss
     - Head-on (large angle): tangential component is small, normal is large → large speed loss
     - This satisfies MECH-08 and CONTEXT.md locked decisions without special-case code
   - Rotate car heading to blend toward wall tangent direction:
     - `impactAngle = acos(clamp(tangentSpeed / speed, 0, 1))`
     - `headingBlend = min(1, impactAngle * 2)` — more rotation for harder impacts
     - `newHeading = lerpAngle(car.heading, wallTangentAngle, headingBlend)`
     - This satisfies CONTEXT.md "nose aligns to wall" decision
   - Push car out of wall: `newPosition = position + normal * (penetration + 0.1)`
   - Dampen yawRate on impact: `yawRate * (1 - impactAngle)` (normalized 0-1)
   - Return new CarState with updated position, velocity, heading, yawRate

   Implementation notes:
   - Per CONTEXT.md: "No bouncing, no deflection. The car rides the wall until player steers away."
   - The formula naturally handles the full spectrum from scrape to head-on without branching:
     - 0-degree scrape: ~0% speed loss (all tangential)
     - 45-degree: ~30% speed loss
     - 90-degree head-on: ~70-100% speed loss (nearly all absorbed by normal, plus friction on remainder)
   - Import WALL_FRICTION from constants.ts
   - This module does NOT call getSurface — surface detection is separate from wall collision

2. Create `tests/engine/collision.test.ts`:

   Test cases:

   **pointToSegmentDistance tests:**
   - Point directly above segment midpoint: nearest point is the projection, distance is perpendicular
   - Point beyond segment end: nearest point is the endpoint, distance is to endpoint
   - Point exactly on segment: distance is 0
   - Point at segment start: t = 0

   **detectWallCollision tests:**
   - Build a simple rectangular track (4 control points forming a rectangle) for testing
   - Car at track center: no collision
   - Car touching inner wall: collision detected with correct normal (pointing outward)
   - Car touching outer wall: collision detected with correct normal (pointing inward)
   - Car far outside: collision detected (penetration > 0)

   **resolveWallCollision tests:**
   - **Glancing hit (shallow angle):** Car moving mostly parallel to wall. Result: small speed reduction (~15-25%), heading barely changes. Verify speed loss is in the expected range per CONTEXT.md.
   - **Moderate hit (45 degrees):** Moderate speed reduction, heading rotates toward wall tangent
   - **Head-on hit (perpendicular):** Near-total speed loss, heading rotates significantly. Verify the car nearly stops per CONTEXT.md "hard impact: near-stop" decision.
   - **Already moving away from wall:** Car has velocity pointing away from wall normal. Result: no change (vDotN >= 0, no resolution needed).
   - **Heading rotation:** After head-on collision, car heading should be closer to wall tangent than before
   - **Position correction:** After collision, car position is pushed outside the wall (distance > radius)
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run tests/engine/collision.test.ts --reporter=verbose</automated>
  </verify>
  <done>
  - pointToSegmentDistance correctly computes nearest point and distance for all edge cases
  - detectWallCollision detects inner and outer wall contact with correct normals
  - resolveWallCollision produces speed penalty proportional to impact angle (glancing ~15-25% loss, head-on near-stop)
  - Wall slide behavior: car slides along wall surface, nose rotates to align with wall
  - No bouncing or deflection — velocity is redirected along wall tangent only
  - Position is corrected to push car out of wall penetration
  - Full test suite passes: `pnpm test` exits 0
  </done>
</task>

</tasks>

<verification>
Run the full test suite including all prior plan tests:

```bash
cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02
pnpm test
npx tsc --noEmit
```

All tests (vec2, spline, track, collision) must pass. TypeScript compiles clean.
</verification>

<success_criteria>
- Track builder converts spline control points into closed boundary polylines
- Surface detection distinguishes road from runoff
- Wall collision detection finds penetration into boundary polylines
- Wall collision response slides car along wall with proportional speed penalty
- Wall contact rotates car nose toward wall direction
- Track 01 is defined with hairpins, sweepers, chicanes, and builds successfully
- All tests pass across this plan and Plan 01
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-simulation-engine/01-02-SUMMARY.md`
</output>
