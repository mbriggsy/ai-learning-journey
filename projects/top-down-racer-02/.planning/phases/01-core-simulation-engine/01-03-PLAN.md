---
phase: 01-core-simulation-engine
plan: 03
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/engine/car.ts
  - tests/engine/car.test.ts
autonomous: true
requirements:
  - MECH-01
  - MECH-02
  - MECH-03
  - MECH-04
  - MECH-05
  - MECH-06

must_haves:
  truths:
    - "Input smoothing gradually transitions steering, throttle, and brake toward target values (not instant snap)"
    - "Steering authority reduces at higher speed (wide arcs at top speed, responsive at low speed)"
    - "Weight transfer shifts load between front and rear axles under braking and acceleration"
    - "Tire force follows simplified Pacejka curve: builds with slip angle, peaks, then falls off"
    - "Car accelerates from rest to ~150-200 units/sec in approximately 4-5 seconds (250-300 ticks)"
    - "Rear tires saturate before front tires under high-speed cornering (oversteer tendency)"
  artifacts:
    - path: "src/engine/car.ts"
      provides: "Car physics: bicycle model with weight transfer, tire forces, input smoothing"
      exports: ["stepCar", "smoothInput", "tireForce", "createInitialCarState"]
      min_lines: 150
    - path: "tests/engine/car.test.ts"
      provides: "Car physics TDD tests"
      min_lines: 150
  key_links:
    - from: "src/engine/car.ts"
      to: "src/engine/vec2.ts"
      via: "import vec2 math for force/velocity calculations"
      pattern: "import.*from.*vec2"
    - from: "src/engine/car.ts"
      to: "src/engine/types.ts"
      via: "import CarState, Input, SmoothedInput, Surface types"
      pattern: "import.*from.*types"
    - from: "src/engine/car.ts"
      to: "src/engine/constants.ts"
      via: "import CAR, TIRE, SURFACE_GRIP, INPUT_RATES, DT, STEER"
      pattern: "import.*from.*constants"
---

<objective>
Implement the car physics module using TDD (Red-Green-Refactor). This is the dynamic bicycle model: weight transfer, tire force curves, slip angles, longitudinal/lateral dynamics, input smoothing, and speed-dependent steering. The car must feel like a rally car per user decisions — loose, slidey, recoverable.

Purpose: This is the heart of the simulation. The car physics model determines how the game feels. Every decision about acceleration, braking, cornering, and sliding flows from this module. TDD ensures each physics behavior is verified before integration.

Output: Working car physics step function with passing tests for all 6 requirement behaviors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/01-CONTEXT.md
@.planning/phases/01-core-simulation-engine/01-RESEARCH.md
@.planning/phases/01-core-simulation-engine/01-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01. -->

From src/engine/types.ts:
```typescript
export interface Vec2 { readonly x: number; readonly y: number; }
export const enum Surface { Road = 0, Runoff = 1 }
export interface Input { steer: number; throttle: number; brake: number; }
export interface SmoothedInput { steer: number; throttle: number; brake: number; steerAngle: number; }
export interface CarState {
  position: Vec2;
  velocity: Vec2;
  heading: number;
  yawRate: number;
  speed: number;
  prevInput: SmoothedInput;
  surface: Surface;
  accelLongitudinal: number;
}
```

From src/engine/constants.ts:
```typescript
export const DT = 1 / 60;
export const CAR = {
  mass: 1200, weight: 1200 * 9.81, wheelbase: 2.6,
  cgToFront: 1.2, cgToRear: 1.4, cgHeight: 0.5,
  length: 4.0, width: 2.0,
  maxEngineForce: 8000, maxBrakeForce: 12000,
  dragCoefficient: 0.4, rollingResistance: 30, maxSpeed: 200,
} as const;
export const TIRE = { B: 8.0, C: 1.4, mu: 1.0 } as const;
export const SURFACE_GRIP: Record<number, number>; // 0: 1.0, 1: 0.5
export const INPUT_RATES = { steer: 4.0, throttle: 6.0, brake: 10.0 } as const;
export const STEER = { maxAngle: 0.6, speedFactor: 0.006 } as const;
```

From src/engine/vec2.ts:
```typescript
export function vec2(x, y): Vec2;
export function add(a, b): Vec2;
export function sub(a, b): Vec2;
export function scale(v, s): Vec2;
export function dot(a, b): number;
export function length(v): number;
export function normalize(v): Vec2;
export function rotate(v, angle): Vec2;
export function fromAngle(angle): Vec2;
```
</interfaces>
</context>

<feature>
  <name>Car Physics Step Function (Dynamic Bicycle Model)</name>
  <files>src/engine/car.ts, tests/engine/car.test.ts</files>
  <behavior>
    The car physics step function takes a CarState and Input, returns a new CarState after one tick (1/60 second).

    **Input Smoothing (MECH-01, MECH-02):**
    - Raw input smoothly transitions toward target using exponential decay: `lerp(prev, target, 1 - exp(-rate * dt))`
    - Steering rate: 4.0 (responsive but not instant)
    - Throttle rate: 6.0 (moderately fast)
    - Brake rate: 10.0 (fastest — brakes should be immediate-feeling)
    - Cases: (prev=0, raw=1.0) after 1 tick → ~0.065 for steer, ~0.095 for throttle, ~0.154 for brake

    **Steering Authority (MECH-06):**
    - Front wheel steer angle = steerInput * maxSteerAngle * speedFactor(speed)
    - speedFactor(speed) = 1.0 / (1.0 + speed * 0.006)
    - Cases: speed=0 → steerAngle = steer * 0.6; speed=100 → steerAngle = steer * 0.6 * 0.625; speed=200 → steerAngle = steer * 0.6 * 0.455

    **Weight Transfer (MECH-03):**
    - Wf = (cgToRear / wheelbase) * weight - (cgHeight / wheelbase) * mass * accel
    - Wr = (cgToFront / wheelbase) * weight + (cgHeight / wheelbase) * mass * accel
    - Under braking (accel < 0): front load increases, rear load decreases
    - Under acceleration (accel > 0): rear load increases, front load decreases
    - Cases: accel=0 → Wf = 6339N, Wr = 5432N (static, rear-biased CG); accel=-5 m/s2 → Wf increases, Wr decreases

    **Tire Force (MECH-04):**
    - F = mu * gripMul * Fz * sin(C * atan(B * slipAngle))
    - Peaks at some slip angle, then falls off (this falloff IS oversteer)
    - Cases: slipAngle=0 → force=0; slipAngle=0.1 → near-peak force; slipAngle=0.5 → past-peak, reduced force
    - Surface.Road: gripMul=1.0; Surface.Runoff: gripMul=0.5

    **Bicycle Model Dynamics:**
    - Transform velocity to car-local frame
    - Compute slip angles for front and rear axles (with low-speed guard: clamp vx >= 0.5)
    - Compute lateral forces from tire model
    - Compute longitudinal force from throttle/brake/drag/rolling resistance
    - Sum forces → linear acceleration, torque → angular acceleration
    - Euler integrate: velocity += accel * dt, position += velocity * dt, heading += yawRate * dt

    **Oversteer Tendency (MECH-05):**
    - CG is rearward of center (cgToRear=1.4 > cgToFront=1.2)
    - Under braking: rear load decreases → rear tires saturate first → rear steps out
    - This emerges naturally from the bicycle model — no special oversteer code

    **Acceleration Target:**
    - With full throttle on Road surface, car should reach ~150-200 units/sec in ~250-300 ticks (4-5 seconds)
    - Top speed limited by drag equilibrium (engine force = drag + rolling resistance)
  </behavior>
  <implementation>
    Implement in src/engine/car.ts with these exported functions:

    **`createInitialCarState(position: Vec2, heading: number): CarState`**
    Factory function creating a car at rest at the given position/heading.

    **`smoothInput(prev: SmoothedInput, raw: Input, speed: number, dt: number): SmoothedInput`**
    Apply exponential smoothing to raw input. Compute steerAngle with speed-dependent authority.

    **`tireForce(slipAngle: number, load: number, gripMul: number): number`**
    Simplified Pacejka: mu * gripMul * load * sin(C * atan(B * slipAngle))

    **`stepCar(car: CarState, input: Input, surface: Surface, dt: number): CarState`**
    Full bicycle model physics step:
    1. Smooth input from raw
    2. Transform velocity to car-local frame (forward/lateral)
    3. Compute weight transfer from previous tick's longitudinal acceleration
    4. Compute slip angles (front and rear) with low-speed guard (absVx >= 0.5)
    5. Compute lateral tire forces (front and rear) using tireForce
    6. Compute longitudinal forces: engine (throttle), braking, drag (proportional to v^2), rolling resistance
    7. Sum forces in car-local frame, transform to world frame
    8. Compute yaw torque from front/rear lateral force imbalance: torque = FlatF * cgToFront - FlatR * cgToRear
    9. Euler integrate: velocity, position, heading, yawRate
    10. Clamp speed to maxSpeed
    11. Return new CarState (never mutate input state)

    Per research pitfalls:
    - Low-speed guard: absVx = max(abs(vLocal.x), 0.5) to prevent division-by-near-zero in slip angle
    - Slip angle sign: use atan2(vy + omega*b, absVx) formulation
    - All state returned as new object (no mutation for determinism)
  </implementation>
</feature>

<verification>
Run the full test suite:

```bash
cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02
pnpm test
npx tsc --noEmit
```

All tests (vec2, spline, car) must pass. TypeScript compiles clean in strict mode.
</verification>

<success_criteria>
- Input smoothing gradually transitions values (not instant) with correct rates
- Steering authority clearly reduces at higher speeds
- Weight transfer shifts load between axles under braking/acceleration
- Tire force curve peaks and falls off (not linear — has saturation)
- Car reaches target speed range (~150-200 units/sec) in ~4-5 seconds with full throttle
- Rear tires saturate before front under high-speed cornering (oversteer tendency measurable in test)
- All physics functions are pure (no mutation of input state)
- No Math.random or external physics dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-simulation-engine/01-03-SUMMARY.md`
</output>
