---
phase: 01-core-simulation-engine
plan: 04
type: execute
wave: 3
depends_on:
  - 01-02
  - 01-03
files_modified:
  - src/engine/checkpoint.ts
  - src/engine/world.ts
  - tests/engine/checkpoint.test.ts
  - tests/engine/world.test.ts
  - tests/engine/determinism.test.ts
autonomous: true
requirements:
  - MECH-10
  - MECH-11
  - MECH-14
  - MECH-15

must_haves:
  truths:
    - "Checkpoint gates are crossed sequentially — skipping a gate does not advance progress"
    - "Crossing the finish gate (checkpoint 0) after all others completes a lap"
    - "Lap timing records ticks elapsed for current lap and tracks best lap across laps"
    - "The world step function orchestrates input smoothing, car physics, collision, surface detection, and checkpoint crossing in one tick"
    - "Identical inputs produce identical WorldState across 10,000 ticks (verified with 100 independent runs producing same hash)"
    - "Natural oversteer emerges when a car enters a fast corner and lifts throttle (rear slip exceeds front slip)"
    - "The simulation runs at 10,000+ ticks/sec headless on a standard dev machine"
  artifacts:
    - path: "src/engine/checkpoint.ts"
      provides: "Checkpoint gate crossing detection and lap timing"
      exports: ["checkGateCrossing", "updateTiming", "createInitialTimingState"]
      min_lines: 60
    - path: "src/engine/world.ts"
      provides: "World state management, step function, initialization"
      exports: ["createWorld", "stepWorld"]
      min_lines: 60
    - path: "tests/engine/checkpoint.test.ts"
      provides: "Checkpoint crossing and lap timing tests"
      min_lines: 60
    - path: "tests/engine/world.test.ts"
      provides: "World step integration tests including oversteer emergence"
      min_lines: 80
    - path: "tests/engine/determinism.test.ts"
      provides: "Determinism verification (identical inputs = identical state)"
      min_lines: 40
  key_links:
    - from: "src/engine/world.ts"
      to: "src/engine/car.ts"
      via: "import stepCar for physics update"
      pattern: "import.*stepCar.*from.*car"
    - from: "src/engine/world.ts"
      to: "src/engine/collision.ts"
      via: "import detectWallCollision, resolveWallCollision"
      pattern: "import.*from.*collision"
    - from: "src/engine/world.ts"
      to: "src/engine/track.ts"
      via: "import getSurface for surface detection"
      pattern: "import.*getSurface.*from.*track"
    - from: "src/engine/world.ts"
      to: "src/engine/checkpoint.ts"
      via: "import updateTiming for checkpoint/lap tracking"
      pattern: "import.*from.*checkpoint"
    - from: "src/engine/checkpoint.ts"
      to: "src/engine/vec2.ts"
      via: "import vec2 for gate crossing geometry"
      pattern: "import.*from.*vec2"
    - from: "tests/engine/determinism.test.ts"
      to: "src/engine/world.ts"
      via: "import createWorld, stepWorld for replay verification"
      pattern: "import.*from.*world"
---

<objective>
Wire all engine modules into the world step function and implement the checkpoint/timing system. Verify determinism (same inputs = same output across runs) and that oversteer emerges naturally from the physics. This completes Phase 1 — the headless simulation is fully functional.

Purpose: This is the integration plan that brings everything together. The world step function is what the renderer (Phase 2) and AI bridge (Phase 4) will call. Determinism is the foundational guarantee for AI training. Oversteer emergence validates that the physics model produces the intended "rally car" feel.

Output: Complete headless simulation that can step a car around a track with checkpoints and lap timing, verified deterministic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/01-CONTEXT.md
@.planning/phases/01-core-simulation-engine/01-RESEARCH.md
@.planning/phases/01-core-simulation-engine/01-01-SUMMARY.md
@.planning/phases/01-core-simulation-engine/01-02-SUMMARY.md
@.planning/phases/01-core-simulation-engine/01-03-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plans 01-03. -->

From src/engine/types.ts:
```typescript
export interface Vec2 { readonly x: number; readonly y: number; }
export const enum Surface { Road = 0, Runoff = 1 }
export interface Input { steer: number; throttle: number; brake: number; }
export interface CarState { position: Vec2; velocity: Vec2; heading: number; yawRate: number; speed: number; prevInput: SmoothedInput; surface: Surface; accelLongitudinal: number; }
export interface Checkpoint { left: Vec2; right: Vec2; center: Vec2; direction: Vec2; arcLength: number; }
export interface TrackState { controlPoints: readonly TrackControlPoint[]; innerBoundary: readonly Vec2[]; outerBoundary: readonly Vec2[]; checkpoints: readonly Checkpoint[]; arcLengthTable: ArcLengthTable; totalLength: number; startPosition: Vec2; startHeading: number; }
export interface CollisionResult { collided: boolean; penetration: number; normal: Vec2; contactPoint: Vec2; }
export interface TimingState { currentLapTicks: number; bestLapTicks: number; currentLap: number; lastCheckpointIndex: number; lapComplete: boolean; }
export interface WorldState { tick: number; car: CarState; track: TrackState; timing: TimingState; }
```

From src/engine/car.ts:
```typescript
export function createInitialCarState(position: Vec2, heading: number): CarState;
export function stepCar(car: CarState, input: Input, surface: Surface, dt: number): CarState;
export function smoothInput(prev: SmoothedInput, raw: Input, speed: number, dt: number): SmoothedInput;
export function tireForce(slipAngle: number, load: number, gripMul: number): number;
```

From src/engine/collision.ts:
```typescript
export function detectWallCollision(position: Vec2, radius: number, track: TrackState): CollisionResult;
export function resolveWallCollision(car: CarState, collision: CollisionResult): CarState;
```

From src/engine/track.ts:
```typescript
export function buildTrack(controlPoints: TrackControlPoint[], checkpointCount: number): TrackState;
export function getSurface(position: Vec2, track: TrackState): Surface;
```

From src/tracks/track01.ts:
```typescript
export const TRACK_01_CONTROL_POINTS: TrackControlPoint[];
```

From src/engine/constants.ts:
```typescript
export const DT = 1 / 60;
export const CAR: { /* ... */ length: 4.0, width: 2.0, /* ... */ };
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Checkpoint System and Lap Timing</name>
  <files>src/engine/checkpoint.ts, tests/engine/checkpoint.test.ts</files>
  <action>
1. Create `src/engine/checkpoint.ts` implementing gate crossing detection and lap timing:

   **`createInitialTimingState(): TimingState`**
   Factory returning initial timing state:
   ```typescript
   { currentLapTicks: 0, bestLapTicks: -1, currentLap: 1, lastCheckpointIndex: -1, lapComplete: false }
   ```
   `lastCheckpointIndex: -1` means no checkpoints crossed yet (car needs to cross checkpoint 0 first to start).

   **`checkGateCrossing(prevPos: Vec2, currPos: Vec2, gate: Checkpoint): boolean`**
   - Determine if the car crossed through a checkpoint gate between two positions
   - Implementation: 2D line segment intersection test between the movement vector (prevPos → currPos) and the gate line (gate.left → gate.right)
   - Must also verify crossing in the correct direction: dot product of movement direction with gate.direction should be positive (car is moving forward through the gate, not backward)
   - Uses cross product method for segment-segment intersection:
     ```
     d1 = cross(gateDir, prevPos - gate.left)
     d2 = cross(gateDir, currPos - gate.left)
     // If d1 and d2 have different signs, car path crosses the gate line
     // Then verify the crossing point is within the gate segment bounds
     ```

   **`updateTiming(timing: TimingState, prevPos: Vec2, currPos: Vec2, checkpoints: readonly Checkpoint[]): TimingState`**
   - Increment `currentLapTicks` by 1 (always, every tick)
   - Check if the car crossed the NEXT expected checkpoint gate:
     - Expected next = `(lastCheckpointIndex + 1) % checkpoints.length`
     - If crossed: update `lastCheckpointIndex` to the crossed gate index
     - If the crossed gate is index 0 AND `lastCheckpointIndex` was the last gate (meaning all gates crossed in order):
       - This is a LAP COMPLETION
       - Set `lapComplete: true`
       - Update `bestLapTicks` = min(bestLapTicks, currentLapTicks) if bestLapTicks > 0, else = currentLapTicks
       - Increment `currentLap`
       - Reset `currentLapTicks` to 0
     - Otherwise: set `lapComplete: false`
   - Checkpoints MUST be crossed in order — skipping a gate does NOT advance progress (MECH-10)
   - Return new TimingState (never mutate)

   Implementation notes:
   - The segment intersection test must handle edge cases: parallel lines (no crossing), crossing exactly at an endpoint, very short movement distances (car nearly stopped)
   - The direction check prevents backward driving from triggering checkpoints
   - Gate index 0 is both the first checkpoint and the finish line

2. Create `tests/engine/checkpoint.test.ts`:

   Test cases:

   **checkGateCrossing tests:**
   - Car crosses gate perpendicular to it (forward direction) → true
   - Car crosses gate at an angle (still forward) → true
   - Car crosses gate backward (wrong direction) → false
   - Car movement does not reach gate → false
   - Car movement parallel to gate → false
   - Car starts exactly on gate line → handle gracefully

   **updateTiming sequential crossing tests:**
   - Set up 4 checkpoint gates in a simple arrangement
   - Cross gate 0 first: lastCheckpointIndex updates to 0
   - Cross gate 1: lastCheckpointIndex updates to 1
   - Skip gate 2, try to cross gate 3: lastCheckpointIndex stays at 1 (no skip allowed)
   - Cross gate 2, then gate 3: lastCheckpointIndex updates correctly

   **updateTiming lap completion tests:**
   - Cross all gates in order (0, 1, 2, 3), then cross gate 0 again: lap completes
   - Verify currentLapTicks resets to 0 on lap completion
   - Verify bestLapTicks is set on first lap completion
   - Complete a second lap faster: bestLapTicks updates to the faster time
   - Complete a third lap slower: bestLapTicks remains the faster time
   - Verify currentLap increments on each completion

   **updateTiming tick counting:**
   - After 60 calls to updateTiming without lap completion: currentLapTicks = 60
   - After lap completion: currentLapTicks resets
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run tests/engine/checkpoint.test.ts --reporter=verbose</automated>
  </verify>
  <done>
  - checkGateCrossing correctly detects forward gate crossings using segment intersection
  - Backward crossings are rejected (direction check works)
  - Checkpoints must be crossed in order — skipping does not advance
  - Lap completion triggers when all gates crossed in order and gate 0 is re-crossed
  - Best lap time tracks the fastest completed lap
  - currentLap increments on each lap completion
  - All timing state is immutable (new objects returned)
  </done>
</task>

<task type="auto">
  <name>Task 2: World Step Function + Determinism + Oversteer Integration</name>
  <files>src/engine/world.ts, tests/engine/world.test.ts, tests/engine/determinism.test.ts</files>
  <action>
1. Create `src/engine/world.ts` — the orchestrator that wires all engine modules:

   **`createWorld(track: TrackState): WorldState`**
   - Create initial car state at track.startPosition with track.startHeading
   - Create initial timing state
   - Return WorldState with tick: 0

   **`stepWorld(state: WorldState, input: Input): WorldState`**
   - This is the CORE function — one tick of simulation. Pure function: `(state, input) → newState`.
   - Step sequence:
     1. Detect surface under car: `getSurface(state.car.position, state.track)`
     2. Step car physics: `stepCar(state.car, input, surface, DT)`
     3. Detect wall collision: `detectWallCollision(newCar.position, CAR.width / 2, state.track)`
     4. Resolve wall collision (if any): `resolveWallCollision(newCar, collision)`
     5. Update surface after collision resolution (position may have changed)
     6. Update timing: `updateTiming(state.timing, state.car.position, resolvedCar.position, state.track.checkpoints)`
     7. Return new WorldState:
        ```typescript
        {
          tick: state.tick + 1,
          car: { ...resolvedCar, surface: newSurface },
          track: state.track,  // immutable reference, same object
          timing: newTiming,
        }
        ```

   Implementation notes:
   - `state.track` is NEVER modified — pass the same reference through. This is critical for memory efficiency during headless training (thousands of episodes share one track).
   - The step function must not use Math.random, Date.now, or any non-deterministic source.
   - DT is imported from constants.ts (1/60), NOT computed from real time.
   - The order matters: physics first, then collision (to prevent tunneling resolution from being overwritten), then checkpoints (to detect gate crossing with the final position).

2. Create `tests/engine/world.test.ts` — integration tests:

   **Basic stepping:**
   - Build track from TRACK_01_CONTROL_POINTS with 30 checkpoints
   - Create world, step with zero input (steer=0, throttle=0, brake=0): car stays at start position (approximately)
   - Step with full throttle for 300 ticks: car should have moved significantly, speed should be near top speed

   **Full lap test:**
   - Create a simple circular/oval test track (4-6 control points)
   - Write a simple steering controller that steers toward the next checkpoint center:
     ```typescript
     function steerTowardTarget(car: CarState, target: Vec2): Input {
       // Compute angle to target, steer toward it
       const toTarget = sub(target, car.position);
       const targetAngle = Math.atan2(toTarget.y, toTarget.x);
       const angleDiff = normalizeAngle(targetAngle - car.heading);
       return { steer: clamp(angleDiff * 2, -1, 1), throttle: 0.5, brake: 0 };
     }
     ```
   - Run for enough ticks to complete at least one lap (~3000-5000 ticks depending on track size)
   - Verify: timing.currentLap > 1 (at least one lap completed)
   - Verify: timing.bestLapTicks > 0 (a lap time was recorded)

   **Wall collision integration:**
   - Create world, steer car directly into outer wall
   - Verify car does not escape the track (position stays inside boundaries after many ticks)
   - Verify car speed reduces on wall contact

   **Surface transition:**
   - Steer car off-track onto runoff surface
   - Verify car.surface changes to Runoff
   - Verify car decelerates faster on runoff (reduced grip)

   **Oversteer emergence test (MECH-05, critical!):**
   - Create world on a test track with a fast corner
   - Drive car at high speed (full throttle for 200+ ticks to reach ~150 units/sec)
   - Enter a corner while holding throttle, then release throttle mid-corner
   - Measure: rear slip angle should exceed front slip angle during throttle lift
   - This proves oversteer emerges from the physics model — no scripted drift
   - Implementation: save slip angles from car state (may need to add them to CarState or compute from velocity/heading)

   **Performance test:**
   - Time 10,000 stepWorld calls
   - Assert total time < 1000ms (>10,000 ticks/sec)
   - This verifies headless training performance target

3. Create `tests/engine/determinism.test.ts`:

   **Determinism test (MECH-14, MECH-15):**
   - Generate a predetermined input sequence of 10,000 inputs:
     ```typescript
     function generateTestInputs(count: number): Input[] {
       const inputs: Input[] = [];
       for (let i = 0; i < count; i++) {
         // Deterministic pattern: sinusoidal steering, varying throttle
         inputs.push({
           steer: Math.sin(i * 0.01) * 0.5,
           throttle: 0.3 + 0.3 * Math.sin(i * 0.005),
           brake: i % 200 < 20 ? 0.5 : 0,
         });
       }
       return inputs;
     }
     ```
   - Run the simulation with these inputs and hash the final WorldState
   - Run again with identical inputs and hash again
   - Assert hashes are identical

   **Multi-run determinism:**
   - Run the same input sequence 100 times
   - Collect all final state hashes into a Set
   - Assert Set size is 1 (all 100 runs produced identical output)
   - This is the Phase 1 success criterion: "identical inputs produce identical state across 10,000 ticks (100 runs, same hash)"

   **State hashing:**
   - Implement a stable hash function that serializes WorldState to a deterministic string:
     ```typescript
     function hashState(state: WorldState): string {
       // Use JSON.stringify with sorted keys and fixed precision
       const normalized = {
         tick: state.tick,
         car: {
           px: state.car.position.x.toFixed(10),
           py: state.car.position.y.toFixed(10),
           vx: state.car.velocity.x.toFixed(10),
           vy: state.car.velocity.y.toFixed(10),
           h: state.car.heading.toFixed(10),
           yr: state.car.yawRate.toFixed(10),
           s: state.car.speed.toFixed(10),
         },
         timing: {
           ticks: state.timing.currentLapTicks,
           best: state.timing.bestLapTicks,
           lap: state.timing.currentLap,
           cp: state.timing.lastCheckpointIndex,
         },
       };
       return JSON.stringify(normalized);
     }
     ```
   - Use toFixed(10) to avoid floating-point display differences while preserving enough precision to detect divergence

   **No Math.random check:**
   - Verify that no file in src/engine/ contains `Math.random`
   - This can be a simple grep assertion or a string search in the test
  </action>
  <verify>
    <automated>cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02 && npx vitest run tests/engine/world.test.ts tests/engine/determinism.test.ts --reporter=verbose</automated>
  </verify>
  <done>
  - stepWorld orchestrates all engine modules in correct order (surface → physics → collision → checkpoints)
  - A simple steering controller can complete a full lap on a test track
  - Wall collisions keep the car inside the track boundaries
  - Oversteer emergence is measurable: rear slip > front slip during throttle-lift in corner
  - 100 independent runs of 10,000 ticks with identical inputs produce identical state hashes
  - Headless performance exceeds 10,000 ticks/sec
  - No Math.random in any engine file
  - Full test suite passes: `pnpm test` exits 0
  </done>
</task>

</tasks>

<verification>
Run the COMPLETE test suite — every test from all 4 plans must pass:

```bash
cd C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02
pnpm test
npx tsc --noEmit
```

Phase 1 success criteria verification:
1. A car can be stepped around a closed track headlessly with analog inputs and lap timing works → world.test.ts full lap test
2. Determinism: identical inputs produce identical state across 10,000 ticks (100 runs, same hash) → determinism.test.ts
3. Car slides along walls with speed penalty and loses grip on runoff → collision.test.ts + world.test.ts
4. Oversteer emerges naturally when pushing through fast corners → world.test.ts oversteer test
5. Headless simulation runs at 10,000+ ticks/sec → world.test.ts performance test
</verification>

<success_criteria>
- Checkpoint gates are crossed in sequence only (no skipping)
- Lap timing correctly tracks current and best lap
- World step function orchestrates all engine systems in one pure function call
- Determinism verified: 100 runs of 10,000 ticks produce identical state hash
- Oversteer emerges from physics (rear slip exceeds front slip under throttle-lift)
- Headless performance exceeds 10,000 ticks/sec
- ALL Phase 1 tests pass (vec2, spline, track, collision, car, checkpoint, world, determinism)
- TypeScript strict mode compiles clean
- Zero Math.random in engine code
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-simulation-engine/01-04-SUMMARY.md`
</output>
