---
phase: 02-pixijs-renderer-playable-game
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
  - src/main.ts
  - src/renderer/GameState.ts
  - src/renderer/InputHandler.ts
  - src/renderer/GameLoop.ts
  - src/renderer/RendererApp.ts
  - vite.config.ts
autonomous: true
requirements: [UX-05, UX-06]

must_haves:
  truths:
    - "Running `pnpm dev` serves the game in a browser without errors"
    - "The loading screen renders: 'Top-Down Racer' title centered with a progress bar below it"
    - "After init completes, the loading screen is removed and the game canvas fills the viewport"
    - "Keyboard input handler captures ArrowUp/Down/Left/Right and WASD simultaneously, arrow keys do not scroll the page"
    - "GamePhase state machine has all five states: Loading, Countdown, Racing, Paused, Respawning"
    - "The fixed-timestep accumulator runs: stepWorld is called at 60Hz independent of display framerate"
  artifacts:
    - path: "index.html"
      provides: "Vite entry point with canvas-ready body"
    - path: "vite.config.ts"
      provides: "Minimal Vite config, no extra plugins needed"
    - path: "src/main.ts"
      provides: "Async entry point: creates RendererApp, awaits init"
    - path: "src/renderer/GameState.ts"
      provides: "GamePhase enum, RaceState interface, mutable game state"
    - path: "src/renderer/InputHandler.ts"
      provides: "Keyboard capture, getInput() returning Input interface"
    - path: "src/renderer/GameLoop.ts"
      provides: "Fixed-timestep accumulator driving stepWorld at 60Hz"
    - path: "src/renderer/RendererApp.ts"
      provides: "PixiJS Application init, two-container scene graph, loading screen"
  key_links:
    - from: "src/main.ts"
      to: "src/renderer/RendererApp.ts"
      via: "new RendererApp(); await app.init()"
    - from: "src/renderer/RendererApp.ts"
      to: "src/renderer/GameLoop.ts"
      via: "app.ticker.add(gameLoop.tick)"
    - from: "src/renderer/GameLoop.ts"
      to: "src/engine/world.ts"
      via: "stepWorld(currState, getInput())"
    - from: "src/renderer/InputHandler.ts"
      to: "src/engine/types.ts"
      via: "returns Input interface"
---

<objective>
Create the Vite entry point, PixiJS Application bootstrap, keyboard input handler, game state machine, and fixed-timestep game loop. This is the foundation everything else builds on.

Purpose: Nothing in Phase 2 can run until PixiJS is initialized, the game loop is stepping the engine, and input is flowing. This plan creates the skeleton; subsequent plans attach renderers and HUD to it.

Output: A browser-loadable game that shows a loading screen (UX-05), then transitions to a black canvas with the engine running headlessly at 60Hz. No track drawn yet — that comes in Plan 02.
</objective>

<execution_context>
@~/.claude/commands/gsd/workflows/execute-plan.md
@~/.claude/commands/gsd/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key engine contracts. Read these — no codebase exploration needed. -->

From src/engine/types.ts:
```typescript
export interface Vec2 { readonly x: number; readonly y: number; }
export interface Input { steer: number; throttle: number; brake: number; }
export interface CarState {
  position: Vec2; velocity: Vec2; heading: number; yawRate: number;
  speed: number; prevInput: SmoothedInput; surface: Surface; accelLongitudinal: number;
}
export interface TimingState {
  currentLapTicks: number; bestLapTicks: number; currentLap: number;
  lastCheckpointIndex: number; lapComplete: boolean;
}
export interface WorldState { tick: number; car: CarState; track: TrackState; timing: TimingState; }
```

From src/engine/world.ts:
```typescript
export function createWorld(track: TrackState): WorldState;
export function stepWorld(state: WorldState, input: Input): WorldState;
```

From src/engine/track.ts:
```typescript
export function buildTrack(controlPoints: readonly TrackControlPoint[]): TrackState;
```

From src/tracks/track01.ts:
```typescript
export const track01ControlPoints: readonly TrackControlPoint[];
```

From src/engine/constants.ts:
```typescript
export const DT = 1 / 60;   // Fixed timestep
export const CAR = { maxSpeed: 200, ... };
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vite config, index.html, and entry point</name>
  <files>
    vite.config.ts
    index.html
    src/main.ts
  </files>
  <action>
Create three files:

**vite.config.ts** (project root):
```typescript
import { defineConfig } from 'vite';
export default defineConfig({
  // No special plugins needed for PixiJS v8
  // TypeScript handled by Vite's built-in esbuild
});
```

**index.html** (project root — standard Vite convention):
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Top-Down Racer</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { background: #000; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

**src/main.ts**:
```typescript
import { RendererApp } from './renderer/RendererApp';

async function main(): Promise<void> {
  const app = new RendererApp();
  await app.init();
}

main().catch(console.error);
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit --project tsconfig.json 2>&1 | head -20 || echo "Files created, tsc may fail until all renderer files exist"</automated>
  </verify>
  <done>index.html exists at project root, src/main.ts imports RendererApp and calls init()</done>
</task>

<task type="auto">
  <name>Task 2: GameState, InputHandler, and GameLoop</name>
  <files>
    src/renderer/GameState.ts
    src/renderer/InputHandler.ts
    src/renderer/GameLoop.ts
  </files>
  <action>
Create three renderer files. The renderer directory does not exist yet — create it.

**src/renderer/GameState.ts** — State machine enum and mutable race state:
```typescript
import type { WorldState } from '../engine/types';
import type { TrackState } from '../engine/types';

export const enum GamePhase {
  Loading    = 'loading',
  Countdown  = 'countdown',
  Racing     = 'racing',
  Paused     = 'paused',
  Respawning = 'respawning',
}

export interface RaceState {
  phase: GamePhase;
  /** Countdown beat index: 3, 2, 1, 0=GO. -1 when not in countdown. */
  countdownBeat: number;
  /** Ticks remaining until next countdown beat. */
  countdownTicksLeft: number;
  /** Ticks of near-zero velocity for stuck detection (MECH-13). */
  stuckTicks: number;
  /** Ticks remaining in the respawn fade (30 ticks = 0.5s). */
  respawnTicksLeft: number;
  /** Whether this is the very first race start (only first gets countdown). */
  initialLoad: boolean;
}

export function createInitialRaceState(): RaceState {
  return {
    phase: GamePhase.Loading,
    countdownBeat: 3,
    countdownTicksLeft: 60, // 1 second per beat
    stuckTicks: 0,
    respawnTicksLeft: 0,
    initialLoad: true,
  };
}
```

**src/renderer/InputHandler.ts** — Keyboard capture, WASD + Arrows, fullscreen:
```typescript
import type { Input } from '../engine/types';

/** Tracks which keys are currently held down. */
const keys = new Set<string>();

/** Initialization flag — attach listeners only once. */
let initialized = false;

export function initInputHandler(): void {
  if (initialized) return;
  initialized = true;

  window.addEventListener('keydown', (e: KeyboardEvent) => {
    keys.add(e.code);
    // Prevent arrow keys from scrolling the page
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', (e: KeyboardEvent) => {
    keys.delete(e.code);
  });
}

/**
 * Returns the current raw digital input state.
 * Keyboard smoothing is handled by the engine's smoothInput() — raw binary values here.
 */
export function getInput(): Input {
  const throttle = (keys.has('ArrowUp')    || keys.has('KeyW')) ? 1.0 : 0.0;
  const brake    = (keys.has('ArrowDown')  || keys.has('KeyS')) ? 1.0 : 0.0;
  const steerL   = (keys.has('ArrowLeft')  || keys.has('KeyA')) ? 1.0 : 0.0;
  const steerR   = (keys.has('ArrowRight') || keys.has('KeyD')) ? 1.0 : 0.0;
  return {
    throttle,
    brake,
    steer: steerR - steerL, // -1.0 (full left) to +1.0 (full right)
  };
}

/** Zero input — used during non-racing phases. */
export const ZERO_INPUT: Input = { steer: 0, throttle: 0, brake: 0 };

/** Returns true if the given key code is currently held. */
export function isKeyDown(code: string): boolean {
  return keys.has(code);
}
```

**src/renderer/GameLoop.ts** — Fixed-timestep accumulator (Gaffer On Games pattern):
```typescript
import { buildTrack } from '../engine/track';
import { createWorld, stepWorld } from '../engine/world';
import { track01ControlPoints } from '../tracks/track01';
import type { WorldState } from '../engine/types';
import { GamePhase, createInitialRaceState, type RaceState } from './GameState';
import { getInput, ZERO_INPUT, isKeyDown } from './InputHandler';

const FIXED_DT_MS = 1000 / 60;       // 16.667ms
const STUCK_SPEED_THRESHOLD = 2.0;   // units/sec — below this counts as stuck
const STUCK_TIMEOUT_TICKS   = 300;   // 5 seconds × 60Hz
const RESPAWN_FADE_TICKS    = 30;    // 0.5s fade-to-black
const COUNTDOWN_BEAT_TICKS  = 60;    // 1 second per beat (3-2-1-GO)
const COUNTDOWN_BEATS       = 3;     // How many numbered beats before GO

/** Callbacks that other renderers register to receive state updates. */
export type RenderCallback = (
  prev: WorldState,
  curr: WorldState,
  alpha: number,
  race: RaceState,
) => void;

export class GameLoop {
  private track = buildTrack(track01ControlPoints);
  private currState: WorldState;
  private prevState: WorldState;
  private raceState: RaceState = createInitialRaceState();
  private accumulator = 0;
  private renderCallbacks: RenderCallback[] = [];

  constructor() {
    this.currState = createWorld(this.track);
    this.prevState = this.currState;
  }

  /** Register a callback called every render frame with interpolation alpha. */
  onRender(cb: RenderCallback): void {
    this.renderCallbacks.push(cb);
  }

  /**
   * Main ticker callback. Called every animation frame by PixiJS Ticker.
   * deltaMS: real elapsed milliseconds since last frame.
   */
  tick(deltaMS: number): void {
    // Cap accumulator to prevent spiral of death after tab switch
    this.accumulator = Math.min(this.accumulator + deltaMS, 200);

    while (this.accumulator >= FIXED_DT_MS) {
      this.prevState = this.currState;
      this.currState = this.stepGame();
      this.accumulator -= FIXED_DT_MS;
    }

    const alpha = this.accumulator / FIXED_DT_MS;
    for (const cb of this.renderCallbacks) {
      cb(this.prevState, this.currState, alpha, this.raceState);
    }
  }

  /** Advance game state by one tick, respecting GamePhase. */
  private stepGame(): WorldState {
    const rs = this.raceState;

    switch (rs.phase) {
      case GamePhase.Loading:
        // Engine runs but nothing happens until transition to Countdown/Racing
        return this.currState;

      case GamePhase.Countdown:
        this.tickCountdown();
        // Physics steps with zero input — car stays pinned at start
        return stepWorld(this.currState, ZERO_INPUT);

      case GamePhase.Racing:
        this.tickRacing();
        return stepWorld(this.currState, getInput());

      case GamePhase.Paused:
        this.tickPaused();
        return this.currState; // Frozen

      case GamePhase.Respawning:
        this.tickRespawning();
        return this.currState; // Frozen during fade
    }
  }

  private tickCountdown(): void {
    const rs = this.raceState;
    rs.countdownTicksLeft--;
    if (rs.countdownTicksLeft <= 0) {
      if (rs.countdownBeat > 0) {
        // Advance to next beat
        rs.countdownBeat--;
        rs.countdownTicksLeft = COUNTDOWN_BEAT_TICKS;
      } else {
        // GO — transition to Racing
        rs.phase = GamePhase.Racing;
      }
    }
  }

  private tickRacing(): void {
    const rs = this.raceState;
    const speed = this.currState.car.speed;

    // Stuck detection (MECH-13)
    if (speed < STUCK_SPEED_THRESHOLD) {
      rs.stuckTicks++;
      if (rs.stuckTicks >= STUCK_TIMEOUT_TICKS) {
        this.beginRespawn();
        return;
      }
    } else {
      rs.stuckTicks = 0;
    }

    // Instant restart (UX-01): R key resets world, no countdown
    if (isKeyDown('KeyR')) {
      this.resetWorld(false);
      return;
    }

    // Pause (UX-02): Escape key
    if (isKeyDown('Escape')) {
      rs.phase = GamePhase.Paused;
      return;
    }
  }

  private tickPaused(): void {
    const rs = this.raceState;
    // Resume on Escape
    if (isKeyDown('Escape')) {
      rs.phase = GamePhase.Racing;
    }
    // R key from pause also instant restarts
    if (isKeyDown('KeyR')) {
      this.resetWorld(false);
    }
  }

  private tickRespawning(): void {
    const rs = this.raceState;
    rs.respawnTicksLeft--;
    if (rs.respawnTicksLeft <= 0) {
      this.completeRespawn();
    }
  }

  private beginRespawn(): void {
    const rs = this.raceState;
    rs.phase = GamePhase.Respawning;
    rs.respawnTicksLeft = RESPAWN_FADE_TICKS;
    rs.stuckTicks = 0;
  }

  private completeRespawn(): void {
    const rs = this.raceState;
    const { timing, track } = this.currState;

    // Determine respawn position: last crossed checkpoint or track start
    const lastIdx = timing.lastCheckpointIndex;
    let respawnPos, respawnHeading: number;
    if (lastIdx >= 0 && lastIdx < track.checkpoints.length) {
      const cp = track.checkpoints[lastIdx];
      respawnPos = cp.center;
      // heading from checkpoint direction (direction is a unit Vec2 in track space)
      respawnHeading = Math.atan2(cp.direction.y, cp.direction.x);
    } else {
      respawnPos = track.startPosition;
      respawnHeading = track.startHeading;
    }

    // Reset car to respawn position using createWorld approach:
    // Rebuild world but preserve timing/lap state
    const freshWorld = createWorld(track);
    this.currState = {
      ...freshWorld,
      car: {
        ...freshWorld.car,
        position: respawnPos,
        heading: respawnHeading,
        velocity: { x: 0, y: 0 },
        speed: 0,
        yawRate: 0,
      },
      timing: this.currState.timing, // Preserve lap progress
    };
    this.prevState = this.currState;
    rs.phase = GamePhase.Racing;
  }

  /** Reset the world. countdown=true for initial load, false for R-key. */
  resetWorld(countdown: boolean): void {
    this.currState = createWorld(this.track);
    this.prevState = this.currState;
    this.raceState = createInitialRaceState();
    if (countdown) {
      this.raceState.phase = GamePhase.Countdown;
    } else {
      // R-key: skip countdown, go straight to Racing
      this.raceState.phase = GamePhase.Racing;
      this.raceState.initialLoad = false;
    }
  }

  /** Transition from Loading to Countdown (initial page load). */
  startGame(): void {
    this.resetWorld(true); // Initial load gets countdown
  }

  get currentWorldState(): WorldState { return this.currState; }
  get currentRaceState(): RaceState { return this.raceState; }
  get trackState() { return this.track; }
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -E "error TS" | head -20 || echo "Type check passed or RendererApp missing (expected at this stage)"</automated>
  </verify>
  <done>
    GameState.ts exports GamePhase enum with all 5 states and createInitialRaceState().
    InputHandler.ts exports initInputHandler(), getInput(), isKeyDown(), ZERO_INPUT.
    GameLoop.ts exports GameLoop class with tick(), onRender(), startGame(), resetWorld().
  </done>
</task>

<task type="auto">
  <name>Task 3: RendererApp with PixiJS init, two-container scene, and loading screen</name>
  <files>
    src/renderer/RendererApp.ts
  </files>
  <action>
Create RendererApp.ts — the top-level coordinator. It:
1. Creates the PixiJS Application (async init — v8 requirement)
2. Shows the loading screen during init (UX-05)
3. Creates the two-container scene graph (world + HUD)
4. Wires the GameLoop to the PixiJS Ticker
5. Starts the game after assets load

```typescript
import { Application, Container, Graphics, Text } from 'pixi.js';
import { GameLoop } from './GameLoop';
import { initInputHandler, isKeyDown } from './InputHandler';
import { GamePhase } from './GameState';

export class RendererApp {
  private app!: Application;
  private worldContainer!: Container;
  private hudContainer!: Container;
  private gameLoop!: GameLoop;

  async init(): Promise<void> {
    // Step 1: Init PixiJS Application (async in v8)
    this.app = new Application();
    await this.app.init({
      resizeTo: window,
      backgroundColor: 0x1a1a1a,
      antialias: true,
      resolution: window.devicePixelRatio ?? 1,
    });
    document.body.appendChild(this.app.canvas);

    // Step 2: Show loading screen (UX-05) — appears immediately after canvas mounts
    const loadingScreen = this.buildLoadingScreen();
    this.app.stage.addChild(loadingScreen);

    // Step 3: Initialize keyboard input
    initInputHandler();

    // Step 4: Wire fullscreen toggle (UX-06: F and F11)
    window.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.code === 'KeyF' || e.code === 'F11') {
        e.preventDefault();
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {});
        } else {
          this.app.canvas.requestFullscreen().catch(() => {});
        }
      }
    });

    // Step 5: Create two-container scene graph
    this.worldContainer = new Container();
    this.hudContainer = new Container();
    // Note: do NOT add to stage yet — loading screen is shown first.
    // Containers are added when game starts.

    // Step 6: Create game loop
    this.gameLoop = new GameLoop();

    // Step 7: Brief simulated loading (PixiJS init is instant for this project;
    //         this gives the browser one frame to paint the loading screen)
    await new Promise<void>((resolve) => {
      this.app.ticker.addOnce(() => {
        // Simulate progress bar completion
        this.updateLoadingProgress(loadingScreen, 1.0);
        resolve();
      });
    });

    // Step 8: Remove loading screen, add game containers
    this.app.stage.removeChild(loadingScreen);
    this.app.stage.addChild(this.worldContainer);
    this.app.stage.addChild(this.hudContainer); // HUD on top of world

    // Step 9: Attach ticker — game loop runs every frame
    this.app.ticker.add((ticker) => {
      this.gameLoop.tick(ticker.deltaMS);
    });

    // Step 10: Start the game with countdown
    this.gameLoop.startGame();
  }

  /** Build the loading screen: title centered, progress bar below. */
  private buildLoadingScreen(): Container {
    const container = new Container();

    // Dark background
    const bg = new Graphics();
    bg.rect(0, 0, window.innerWidth, window.innerHeight).fill(0x0a0a0a);
    container.addChild(bg);

    // Game title
    const title = new Text({
      text: 'Top-Down Racer',
      style: {
        fontFamily: 'monospace',
        fontSize: 48,
        fill: '#ffffff',
        fontWeight: 'bold',
        letterSpacing: 4,
      },
    });
    title.anchor.set(0.5);
    title.x = window.innerWidth / 2;
    title.y = window.innerHeight / 2 - 40;
    container.addChild(title);

    // Progress bar background
    const barW = 300;
    const barH = 6;
    const barX = window.innerWidth / 2 - barW / 2;
    const barY = window.innerHeight / 2 + 20;

    const barBg = new Graphics();
    barBg.rect(barX, barY, barW, barH).fill(0x333333);
    container.addChild(barBg);

    // Progress bar fill (starts empty — updated via updateLoadingProgress)
    const barFill = new Graphics();
    barFill.name = 'progress-fill';
    barFill.rect(barX, barY, 0, barH).fill(0x44aaff);
    container.addChild(barFill);

    // Store barX/barW for update
    (container as any).__barX = barX;
    (container as any).__barY = barY;
    (container as any).__barW = barW;
    (container as any).__barH = barH;

    return container;
  }

  /** Update the loading progress bar fill (0.0 to 1.0). */
  private updateLoadingProgress(screen: Container, progress: number): void {
    const barFill = screen.getChildByName('progress-fill') as Graphics;
    if (!barFill) return;
    const { __barX: x, __barY: y, __barW: w, __barH: h } = screen as any;
    barFill.clear();
    barFill.rect(x, y, w * progress, h).fill(0x44aaff);
  }

  get pixiApp(): Application { return this.app; }
  get world(): Container { return this.worldContainer; }
  get hud(): Container { return this.hudContainer; }
  get loop(): GameLoop { return this.gameLoop; }
}
```

Key implementation notes:
- `await app.init()` is required in PixiJS v8 — synchronous construction is invalid
- Loading screen appears before any game containers to satisfy UX-05 (loading screen during asset loading)
- The world container goes on stage first; HUD second — HUD renders on top
- `ticker.deltaMS` (not `ticker.deltaTime`) feeds the accumulator with real milliseconds
- Fullscreen uses `keydown` event — this IS a user gesture, `requestFullscreen()` is valid here
- F11 behavior is browser-dependent; F is the reliable game trigger (per research pitfalls)
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" || echo "0 errors"</automated>
  </verify>
  <done>
    TypeScript compiles with zero errors.
    RendererApp.ts exports RendererApp class with async init().
    Loading screen displays during init (UX-05 satisfied at module level).
    worldContainer and hudContainer are accessible for Plan 02 and Plan 03.
    GameLoop is wired to app.ticker.
  </done>
</task>

</tasks>

<verification>
After all three tasks:
1. `pnpm exec tsc --noEmit` passes with zero type errors
2. `pnpm dev` serves without errors (check browser console)
3. Browser shows loading screen: "Top-Down Racer" title + progress bar, then transitions to dark canvas
4. Arrow keys do not scroll the browser page during gameplay
5. F key toggles fullscreen
</verification>

<success_criteria>
- TypeScript compiles clean (0 errors)
- Browser loads, shows loading screen, transitions to game canvas
- No PixiJS import exists anywhere under src/engine/ (CLAUDE.md constraint)
- GameLoop steps world at 60Hz via fixed-timestep accumulator
- Input handler captures both WASD and arrow keys simultaneously
</success_criteria>

<output>
After completion, create `.planning/phases/02-pixijs-renderer-playable-game/02-01-SUMMARY.md`
</output>
