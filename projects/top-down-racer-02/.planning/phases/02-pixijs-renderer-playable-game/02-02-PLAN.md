---
phase: 02-pixijs-renderer-playable-game
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/renderer/CameraController.ts
  - src/renderer/TrackRenderer.ts
  - src/renderer/CarRenderer.ts
  - src/renderer/WorldRenderer.ts
  - src/renderer/RendererApp.ts
autonomous: true
requirements: [VIS-01, VIS-02, VIS-05]

must_haves:
  truths:
    - "The track renders as colored polygons: dark grey road, light tan runoff background, red-brown wall strokes"
    - "The finish line renders as a checkered strip (alternating black/white squares) at checkpoint[0]"
    - "The car renders as an arrow-like rectangle with a pointed nose indicating heading direction"
    - "The car sprite rotates smoothly between ticks — no discrete jumps at 60Hz boundaries"
    - "The camera follows the car: car always points toward the top of the screen (car-facing-up)"
    - "Camera zoom is medium-tight (~3x), pulls out at high speed, pulls out extra when yawRate is large (sliding)"
    - "Camera position and zoom transitions are smoothly lerped — no snapping"
    - "Track is drawn once and cached as a GPU texture — not redrawn every frame"
  artifacts:
    - path: "src/renderer/CameraController.ts"
      provides: "Camera transform: pivot, position, rotation, zoom with lerp"
    - path: "src/renderer/TrackRenderer.ts"
      provides: "Static track geometry built once and cached via cacheAsTexture()"
    - path: "src/renderer/CarRenderer.ts"
      provides: "Car Graphics object, updated each frame with interpolated position+heading"
    - path: "src/renderer/WorldRenderer.ts"
      provides: "Orchestrator: reads WorldState + alpha, drives Camera + Car updates"
  key_links:
    - from: "src/renderer/WorldRenderer.ts"
      to: "src/renderer/CameraController.ts"
      via: "updateCamera(worldContainer, interpPos, interpHeading, zoom)"
    - from: "src/renderer/WorldRenderer.ts"
      to: "src/renderer/CarRenderer.ts"
      via: "updateCar(interpPos, interpHeading)"
    - from: "src/renderer/RendererApp.ts"
      to: "src/renderer/WorldRenderer.ts"
      via: "gameLoop.onRender(worldRenderer.render)"
    - from: "src/renderer/TrackRenderer.ts"
      to: "src/engine/types.ts"
      via: "buildTrackGraphics(track: TrackState)"
---

<objective>
Draw the track and car in the PixiJS scene graph with a car-facing-up camera, render interpolation for smooth motion, and dynamic zoom. The game becomes visually playable after this plan.

Purpose: This is the visual core — without it the game is a black canvas. The camera, car sprite, track geometry, and finish line are all defined here.

Output: Track drawn once + cached, car sprite updating each frame at interpolated position/heading, camera keeping car centered and facing up, dynamic zoom responding to speed and slides.
</objective>

<execution_context>
@~/.claude/commands/gsd/workflows/execute-plan.md
@~/.claude/commands/gsd/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-pixijs-renderer-playable-game/02-01-SUMMARY.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key contracts from Plan 01 and the engine. No codebase exploration needed. -->

From src/renderer/RendererApp.ts (Plan 01 output):
```typescript
export class RendererApp {
  get pixiApp(): Application;
  get world(): Container;  // worldContainer — camera transforms applied here
  get hud(): Container;    // hudContainer — HUD only
  get loop(): GameLoop;
}
```

From src/renderer/GameLoop.ts (Plan 01 output):
```typescript
export type RenderCallback = (prev: WorldState, curr: WorldState, alpha: number, race: RaceState) => void;
export class GameLoop {
  onRender(cb: RenderCallback): void;
  get trackState(): TrackState;
}
```

From src/engine/types.ts:
```typescript
export interface CarState {
  position: Vec2; heading: number; yawRate: number; speed: number;
}
export interface TrackState {
  innerBoundary: readonly Vec2[];
  outerBoundary: readonly Vec2[];
  checkpoints: readonly Checkpoint[];  // checkpoints[0] = finish line
  startPosition: Vec2; startHeading: number;
}
export interface Checkpoint {
  left: Vec2; right: Vec2; center: Vec2; direction: Vec2; arcLength: number;
}
export interface WorldState { car: CarState; track: TrackState; timing: TimingState; }
```

From src/engine/constants.ts:
```typescript
export const CAR = { maxSpeed: 200, length: 4.0, width: 2.0, ... };
```

Coordinate system:
- Engine: Y-up (math standard), heading 0 = +X (east), heading increases CCW
- PixiJS: Y-down (screen standard)
- Camera rotation formula: worldContainer.rotation = -(heading + Math.PI / 2)
  Maps engine heading 0 (east) → screen up (car always points up)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: CameraController and TrackRenderer</name>
  <files>
    src/renderer/CameraController.ts
    src/renderer/TrackRenderer.ts
  </files>
  <action>
**src/renderer/CameraController.ts** — Car-facing-up camera with dynamic zoom:

```typescript
import type { Container } from 'pixi.js';
import type { CarState } from '../engine/types';
import { CAR } from '../engine/constants';

// Zoom constants (pixels per world unit)
const ZOOM_BASE   = 3.0;
const ZOOM_MIN    = 2.5;  // Widest — high speed
const ZOOM_MAX    = 3.5;  // Tightest — low speed / corners
const ZOOM_SLIDE_BONUS = 0.4;  // Extra zoom-out when sliding
const SLIDE_THRESHOLD  = 1.5;  // |yawRate| above this = sliding

// Camera position lerp (smoothing)
const CAM_POS_LERP  = 0.12; // ~12% per frame — slight lag for feel
const CAM_ZOOM_LERP = 0.05; // ~5% per frame — smooth zoom transitions

export class CameraController {
  private currentZoom = ZOOM_BASE;
  private targetZoom  = ZOOM_BASE;

  /**
   * Apply camera transform to the world container.
   * Called every render frame with an interpolated car state.
   *
   * @param worldContainer - The container holding all world objects
   * @param carX - Interpolated car world X position
   * @param carY - Interpolated car world Y position
   * @param carHeading - Interpolated car heading (radians, engine convention)
   * @param screenW - Canvas width in pixels
   * @param screenH - Canvas height in pixels
   */
  update(
    worldContainer: Container,
    carX: number,
    carY: number,
    carHeading: number,
    screenW: number,
    screenH: number,
    car: CarState,
  ): void {
    const cx = screenW / 2;
    const cy = screenH / 2;

    // 1. Compute target zoom from speed and slide state
    const speedFactor = Math.min(car.speed / CAR.maxSpeed, 1.0);
    this.targetZoom = ZOOM_MAX - (ZOOM_MAX - ZOOM_MIN) * speedFactor;
    if (Math.abs(car.yawRate) > SLIDE_THRESHOLD) {
      this.targetZoom -= ZOOM_SLIDE_BONUS;
    }
    this.targetZoom = Math.max(ZOOM_MIN - ZOOM_SLIDE_BONUS, Math.min(ZOOM_MAX, this.targetZoom));

    // 2. Lerp current zoom toward target (smooth transitions)
    this.currentZoom += (this.targetZoom - this.currentZoom) * CAM_ZOOM_LERP;

    // 3. Set world container transforms
    //    pivot = car world position (point to rotate/zoom around)
    //    position = screen center (pivot maps to here)
    worldContainer.pivot.set(carX, carY);
    worldContainer.position.set(cx, cy);

    // 4. Car-facing-up rotation:
    //    Engine heading 0 = east (+X), we want car to face screen-up.
    //    PixiJS rotation is clockwise in screen space (Y-down).
    //    -(heading + PI/2) maps engine east → screen up.
    worldContainer.rotation = -(carHeading + Math.PI / 2);

    // 5. Apply zoom
    worldContainer.scale.set(this.currentZoom);
  }

  reset(): void {
    this.currentZoom = ZOOM_BASE;
    this.targetZoom  = ZOOM_BASE;
  }
}
```

**src/renderer/TrackRenderer.ts** — Static track geometry, cached as GPU texture:

```typescript
import { Container, Graphics } from 'pixi.js';
import type { TrackState } from '../engine/types';

// Track surface colors (locked decisions from CONTEXT.md)
const COLOR_ROAD_SURFACE   = 0x3a3a3a; // Dark grey — safe
const COLOR_RUNOFF_BG      = 0xc2a87a; // Light tan — warning zone
const COLOR_WALL_STROKE    = 0x7b3b2a; // Red-brown — danger
const COLOR_FINISH_WHITE   = 0xffffff;
const COLOR_FINISH_DARK    = 0x111111;

const WALL_STROKE_WIDTH    = 2.0;
const FINISH_SQUARES       = 10; // Number of alternating squares across finish line

/**
 * Build all track graphics and cache them as a single GPU texture.
 * Called once at startup. Returns a Container added to worldContainer.
 *
 * Layer order (back to front):
 *   1. Runoff background (full outer polygon, light tan)
 *   2. Road surface (outer minus inner, dark grey)
 *   3. Wall boundary strokes (red-brown lines)
 *   4. Finish line (checkered strip at checkpoint[0])
 */
export function buildTrackGraphics(track: TrackState): Container {
  const container = new Container();

  // Helper: Vec2[] → flat number array [x0, y0, x1, y1, ...]
  function flatten(pts: readonly { x: number; y: number }[]): number[] {
    const arr: number[] = [];
    for (const p of pts) { arr.push(p.x, p.y); }
    return arr;
  }

  // 1. Runoff background — full outer boundary filled light tan
  const runoff = new Graphics();
  runoff.poly(flatten(track.outerBoundary)).fill(COLOR_RUNOFF_BG);
  container.addChild(runoff);

  // 2. Road surface — outer polygon filled dark grey, inner polygon cut out
  //    .cut() punches a hole using the winding rule
  const road = new Graphics();
  road.poly(flatten(track.outerBoundary)).fill(COLOR_ROAD_SURFACE);
  road.poly(flatten(track.innerBoundary)).cut();
  container.addChild(road);

  // 3. Wall boundary strokes — both inner and outer edges, red-brown
  const walls = new Graphics();
  walls.poly(flatten(track.outerBoundary)).stroke({ width: WALL_STROKE_WIDTH, color: COLOR_WALL_STROKE });
  walls.poly(flatten(track.innerBoundary)).stroke({ width: WALL_STROKE_WIDTH, color: COLOR_WALL_STROKE });
  container.addChild(walls);

  // 4. Finish line — checkered strip at checkpoint[0] (VIS-05)
  //    The finish gate has .left and .right defining the gate endpoints.
  if (track.checkpoints.length > 0) {
    const finishLine = buildFinishLine(track);
    container.addChild(finishLine);
  }

  // Cache entire track as GPU texture — never redrawn
  container.cacheAsTexture();

  return container;
}

/** Build the checkered finish line strip at checkpoint[0]. */
function buildFinishLine(track: TrackState): Graphics {
  const gate = track.checkpoints[0];
  const g = new Graphics();

  for (let i = 0; i < FINISH_SQUARES; i++) {
    const t0 = i / FINISH_SQUARES;
    const t1 = (i + 1) / FINISH_SQUARES;

    // Interpolate across the gate left → right
    const x0 = gate.left.x + (gate.right.x - gate.left.x) * t0;
    const y0 = gate.left.y + (gate.right.y - gate.left.y) * t0;
    const x1 = gate.left.x + (gate.right.x - gate.left.x) * t1;
    const y1 = gate.left.y + (gate.right.y - gate.left.y) * t1;

    // Gate direction perpendicular (the "thickness" of the strip along the track)
    // gate.direction is the unit vector along the track centerline at this gate
    const perpX = -gate.direction.y;
    const perpY =  gate.direction.x;
    const halfThick = 2.5; // Half-thickness of the checkered strip in world units

    // Quad corners for this square
    const qx0 = x0 + perpX * halfThick;
    const qy0 = y0 + perpY * halfThick;
    const qx1 = x1 + perpX * halfThick;
    const qy1 = y1 + perpY * halfThick;
    const qx2 = x1 - perpX * halfThick;
    const qy2 = y1 - perpY * halfThick;
    const qx3 = x0 - perpX * halfThick;
    const qy3 = y0 - perpY * halfThick;

    const color = i % 2 === 0 ? COLOR_FINISH_WHITE : COLOR_FINISH_DARK;
    g.poly([qx0, qy0, qx1, qy1, qx2, qy2, qx3, qy3]).fill(color);
  }

  return g;
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "CameraController\|TrackRenderer" | head -10 || echo "No errors in these files"</automated>
  </verify>
  <done>
    CameraController.ts exports CameraController class with update() and reset().
    TrackRenderer.ts exports buildTrackGraphics(track: TrackState): Container.
    Both compile without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: CarRenderer, WorldRenderer, and wire into RendererApp</name>
  <files>
    src/renderer/CarRenderer.ts
    src/renderer/WorldRenderer.ts
    src/renderer/RendererApp.ts
  </files>
  <action>
**src/renderer/CarRenderer.ts** — Car sprite as arrow-like rectangle with pointed nose:

```typescript
import { Graphics, Container } from 'pixi.js';
import { CAR } from '../engine/constants';

// Car visual dimensions (in world units — same scale as physics)
const CAR_LENGTH = CAR.length;  // 4.0 world units
const CAR_WIDTH  = CAR.width;   // 2.0 world units
const NOSE_LENGTH = 0.8;         // Extra forward protrusion for the "pointed nose"

// Car color — white body, distinct from AI car (Phase 6 will use different color)
const CAR_BODY_COLOR = 0xeeeeee;
const CAR_NOSE_COLOR = 0xff4444; // Red nose accent for forward direction readability

export class CarRenderer {
  readonly container: Container;
  private body: Graphics;
  private nose: Graphics;

  constructor() {
    this.container = new Container();

    // Body: rectangle centered at origin, heading is +X axis (engine convention).
    // PixiJS container transform handles world positioning and rotation.
    // Half-dimensions:
    const hw = CAR_WIDTH / 2;
    const hl = CAR_LENGTH / 2;

    this.body = new Graphics();
    // Rectangle from (-hl, -hw) to (+hl, +hw)
    this.body.rect(-hl, -hw, CAR_LENGTH, CAR_WIDTH).fill(CAR_BODY_COLOR);
    this.container.addChild(this.body);

    // Nose: small triangle at the front (+X direction) for heading clarity
    this.nose = new Graphics();
    this.nose.poly([
       hl + NOSE_LENGTH, 0,   // tip of nose (forward)
       hl, -hw * 0.6,          // left of nose base
       hl,  hw * 0.6,          // right of nose base
    ]).fill(CAR_NOSE_COLOR);
    this.container.addChild(this.nose);
  }

  /**
   * Update car sprite position and heading each render frame.
   * Called with interpolated values (not raw tick state).
   *
   * @param worldX - Interpolated world X position
   * @param worldY - Interpolated world Y position
   * @param heading - Interpolated heading in radians (engine: 0 = +X east)
   */
  update(worldX: number, worldY: number, heading: number): void {
    this.container.position.set(worldX, worldY);
    // Engine heading 0 = +X. PixiJS rotation 0 = +X (same x-axis convention).
    // But PixiJS Y is down (clockwise positive), engine Y is up (CCW positive).
    // Car shape is drawn with forward = +X, so PixiJS rotation = -heading
    // to flip from engine CCW convention to PixiJS CW convention.
    // The camera also applies worldContainer.rotation = -(heading + PI/2),
    // which already flips world Y. The car container's own rotation corrects for
    // the Y-flip: rotation = heading (not negated) within the already-flipped world.
    this.container.rotation = heading;
  }
}
```

**src/renderer/WorldRenderer.ts** — Orchestrator for all world-space rendering:

```typescript
import type { Container } from 'pixi.js';
import type { WorldState } from '../engine/types';
import type { RaceState } from './GameState';
import { GamePhase } from './GameState';
import { CameraController } from './CameraController';
import { CarRenderer } from './CarRenderer';
import { buildTrackGraphics } from './TrackRenderer';

/** Linear interpolation. */
function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

/**
 * Angle-aware lerp that avoids spinning the wrong way at the ±PI boundary.
 * The difference is wrapped to [-PI, PI] before interpolating.
 */
function lerpAngle(a: number, b: number, t: number): number {
  let diff = b - a;
  while (diff >  Math.PI) diff -= 2 * Math.PI;
  while (diff < -Math.PI) diff += 2 * Math.PI;
  return a + diff * t;
}

export class WorldRenderer {
  private camera: CameraController;
  private carRenderer: CarRenderer;
  private trackBuilt = false;

  constructor(private worldContainer: Container) {
    this.camera = new CameraController();
    this.carRenderer = new CarRenderer();
  }

  /**
   * Initialize track rendering (called once after game start, track is immutable).
   * Builds track graphics and adds them to worldContainer before the car.
   */
  initTrack(track: WorldState['track']): void {
    if (this.trackBuilt) return;
    const trackGraphics = buildTrackGraphics(track);
    this.worldContainer.addChild(trackGraphics);   // Track first (behind car)
    this.worldContainer.addChild(this.carRenderer.container); // Car on top
    this.trackBuilt = true;
  }

  /**
   * Main render function — called every animation frame by GameLoop.onRender().
   *
   * @param prev - WorldState at the previous physics tick
   * @param curr - WorldState at the current physics tick
   * @param alpha - Interpolation factor 0..1 (accumulator position)
   * @param race - Current game phase state
   */
  render(
    prev: WorldState,
    curr: WorldState,
    alpha: number,
    race: RaceState,
  ): void {
    // Initialize track on first render (after GameLoop has built the world)
    if (!this.trackBuilt) {
      this.initTrack(curr.track);
    }

    // Compute interpolated car position and heading
    const carX = lerp(prev.car.position.x, curr.car.position.x, alpha);
    const carY = lerp(prev.car.position.y, curr.car.position.y, alpha);
    const carHeading = lerpAngle(prev.car.heading, curr.car.heading, alpha);

    // Update car sprite (interpolated position+heading for smooth motion — VIS-02)
    this.carRenderer.update(carX, carY, carHeading);

    // Update camera (car-facing-up, dynamic zoom — VIS-01)
    const screenW = this.worldContainer.parent?.parent
      ? (this.worldContainer.parent.parent as any).screen?.width ?? window.innerWidth
      : window.innerWidth;
    const screenH = this.worldContainer.parent?.parent
      ? (this.worldContainer.parent.parent as any).screen?.height ?? window.innerHeight
      : window.innerHeight;

    this.camera.update(
      this.worldContainer,
      carX,
      carY,
      carHeading,
      screenW,
      screenH,
      curr.car,
    );
  }

  reset(): void {
    this.camera.reset();
  }
}
```

**Update src/renderer/RendererApp.ts** — Wire WorldRenderer into the existing app:

Read the current RendererApp.ts (created in Plan 01). Add WorldRenderer wiring:

1. Add import: `import { WorldRenderer } from './WorldRenderer';`
2. Add private field: `private worldRenderer!: WorldRenderer;`
3. In `init()`, after creating worldContainer and hudContainer but before `ticker.add()`, add:
   ```typescript
   this.worldRenderer = new WorldRenderer(this.worldContainer);
   this.gameLoop.onRender((prev, curr, alpha, race) => {
     this.worldRenderer.render(prev, curr, alpha, race);
   });
   ```

The minimal change is to add the WorldRenderer wiring lines to the existing init() method. Do NOT rewrite the entire file — only add these lines in the correct position.

For the camera to read screen dimensions correctly, pass `this.app.screen.width` and `this.app.screen.height` from the RendererApp through to WorldRenderer. Update WorldRenderer.render() to accept optional screen dimensions, or have RendererApp pass them via a closure:

In RendererApp.init(), replace the onRender registration with:
```typescript
this.worldRenderer = new WorldRenderer(this.worldContainer);
this.gameLoop.onRender((prev, curr, alpha, race) => {
  this.worldRenderer.render(prev, curr, alpha, race, this.app.screen.width, this.app.screen.height);
});
```

And update WorldRenderer.render() signature to accept screenW and screenH as final parameters instead of reading from parent chain:
```typescript
render(prev, curr, alpha, race, screenW: number, screenH: number): void
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "errors found" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    CarRenderer.ts exports CarRenderer class — draws rectangle + pointed nose, update(x, y, heading) works.
    WorldRenderer.ts exports WorldRenderer class — orchestrates track init, car update, camera update each frame.
    RendererApp.ts wires WorldRenderer into the render callback.
    TypeScript compiles with 0 errors.
    Running pnpm dev shows the track and car on screen.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Track rendering (dark grey road, light tan runoff, red-brown walls, checkered finish line at checkpoint[0]),
    car sprite (rectangle with pointed nose, heading visible),
    car-facing-up camera following the car (car always points up on screen),
    dynamic zoom (tighter at slow speed, wider at high speed, wider on big slides).
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev` in the project directory
    2. Open http://localhost:5173 in a browser
    3. Confirm: track is visible as colored shapes (dark grey road, tan border, red-brown wall lines)
    4. Confirm: checkered strip visible at the finish line position
    5. Confirm: car shape visible as a white rectangle with a red pointed nose
    6. Drive with WASD or Arrow keys — car moves, camera rotates so car always faces screen top
    7. Accelerate on a straight — confirm camera pulls back slightly at high speed
    8. Hit a corner or slide — confirm extra zoom-out during slide
    9. Car heading transitions smoothly (no spinning at direction wrap)
  </how-to-verify>
  <resume-signal>Type "approved" when visuals look correct, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. Track renders with correct surface colors (dark grey road, tan runoff, red-brown walls)
3. Finish line renders as checkered strip at the start/finish position
4. Car sprite has visible heading arrow (pointed nose)
5. Camera rotation keeps car pointing up at all times
6. Camera zoom responds to speed and slide state
7. No PixiJS imports in src/engine/ files
</verification>

<success_criteria>
- VIS-01: Camera follows car with lerp, car-facing-up rotation applied
- VIS-02: Car sprite rotation interpolated between ticks (lerpAngle used, no jumps)
- VIS-05: Checkered finish line strip rendered at checkpoint[0]
- Track drawn once, cached as GPU texture
- Playable visually: can drive around track and see car + track in browser
</success_criteria>

<output>
After completion, create `.planning/phases/02-pixijs-renderer-playable-game/02-02-SUMMARY.md`
</output>
