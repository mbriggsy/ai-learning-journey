---
phase: 02-pixijs-renderer-playable-game
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/renderer/HudRenderer.ts
  - src/renderer/RendererApp.ts
autonomous: true
requirements: [HUD-01, HUD-02, HUD-03, HUD-04, HUD-05]

must_haves:
  truths:
    - "Speedometer renders as a vertical bar in the bottom-left — bar fill scales with car speed"
    - "Current lap time displays in top-right, formatted M:SS.mmm, updates every frame"
    - "Best lap time displays in top-right below current time — shows 'Best: --:--.---' before first completion"
    - "Lap counter displays in top-left as 'LAP X' updating when new lap starts"
    - "Minimap renders in bottom-right: thin track outline with a dot for car position"
    - "All HUD elements have semi-transparent dark panel backgrounds (60-70% opacity)"
    - "Lap time text flashes green on new best lap completion"
    - "Text objects only update their .text property when the displayed value actually changes (no per-frame GC)"
  artifacts:
    - path: "src/renderer/HudRenderer.ts"
      provides: "All 5 HUD elements: speedometer, lap time, best lap, lap counter, minimap"
  key_links:
    - from: "src/renderer/HudRenderer.ts"
      to: "src/engine/types.ts"
      via: "reads WorldState.car.speed, WorldState.timing.*"
    - from: "src/renderer/RendererApp.ts"
      to: "src/renderer/HudRenderer.ts"
      via: "gameLoop.onRender — HudRenderer.render(prev, curr, alpha, race)"
---

<objective>
Build the complete HUD: speedometer bar, current lap time, best lap time, lap counter, and minimap. All elements use corner-only layout with dark panel backgrounds. The minimap shows the track outline and car dot.

Purpose: The HUD delivers the racing feedback loop — speed awareness, time pressure, lap progress, and spatial awareness. All five HUD requirements (HUD-01 through HUD-05) are addressed in this single plan.

Output: HudRenderer class attached to hudContainer with all five elements updating in real time from WorldState.
</objective>

<execution_context>
@~/.claude/commands/gsd/workflows/execute-plan.md
@~/.claude/commands/gsd/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-pixijs-renderer-playable-game/02-01-SUMMARY.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key contracts from Plan 01 and the engine. -->

From src/renderer/RendererApp.ts (Plan 01 output):
```typescript
export class RendererApp {
  get hud(): Container;   // hudContainer — HUD lives here, fixed to screen
  get loop(): GameLoop;
  get pixiApp(): Application;
}
```

From src/renderer/GameLoop.ts (Plan 01 output):
```typescript
export type RenderCallback = (prev: WorldState, curr: WorldState, alpha: number, race: RaceState) => void;
export class GameLoop { onRender(cb: RenderCallback): void; }
```

From src/engine/types.ts:
```typescript
export interface CarState { speed: number; }
export interface TimingState {
  currentLapTicks: number;  // Ticks in current lap (1 tick = 1/60s)
  bestLapTicks: number;     // -1 if no completed lap yet
  currentLap: number;       // 1-indexed, increments on lap completion
  lastCheckpointIndex: number;
  lapComplete: boolean;     // true ONLY on the tick a lap finishes
}
export interface WorldState { car: CarState; track: TrackState; timing: TimingState; }
export interface TrackState {
  outerBoundary: readonly Vec2[];
  innerBoundary: readonly Vec2[];
}
```

From src/engine/constants.ts:
```typescript
export const CAR = { maxSpeed: 200 };
```

User decisions (CONTEXT.md — locked):
- HUD layout: corners only
- Speedometer: vertical bar fill (bottom-left)
- Lap counter: top-left — 'LAP X'
- Lap time + best lap: top-right, stacked
- Minimap: bottom-right, outline + dot
- HUD backgrounds: semi-transparent dark panels (~65% opacity)
- Best lap: always visible as 'Best: --:--.---' before first lap
- Lap time feedback: green flash for new best
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: HudRenderer — all 5 HUD elements</name>
  <files>
    src/renderer/HudRenderer.ts
  </files>
  <action>
Create HudRenderer.ts with all 5 HUD elements. The HUD container is fixed to screen space — no camera transforms affect it.

```typescript
import { Container, Graphics, Text } from 'pixi.js';
import type { WorldState } from '../engine/types';
import type { RaceState } from './GameState';
import { CAR } from '../engine/constants';

// ──────────────────────────────────────────────────────────
// Layout constants (screen coordinates)
// ──────────────────────────────────────────────────────────
const MARGIN = 16;         // Padding from screen edge
const PANEL_ALPHA = 0.65;  // Semi-transparent dark panel opacity
const PANEL_RADIUS = 4;    // Rounded corners (visual only — using rect)

// Speedometer (bottom-left)
const SPEED_BAR_W    = 18;   // Bar width in pixels
const SPEED_BAR_H    = 100;  // Bar max height in pixels
const SPEED_BAR_COLOR = 0x44ffaa;

// Minimap (bottom-right)
const MINIMAP_SIZE   = 120;  // Width and height of minimap area in pixels
const MINIMAP_SCALE  = 0.22; // World units → minimap pixels (track ~400 units wide → ~88px)
const MINIMAP_DOT    = 3;    // Car dot radius in pixels
const MINIMAP_TRACK_COLOR = 0xaaaaaa;
const MINIMAP_CAR_COLOR   = 0xffff00;

// Text style shared across HUD
const HUD_TEXT_STYLE = {
  fontFamily: 'monospace',
  fontSize: 14,
  fill: '#ffffff',
} as const;

const HUD_TEXT_STYLE_SMALL = {
  fontFamily: 'monospace',
  fontSize: 12,
  fill: '#aaaaaa',
} as const;

// ──────────────────────────────────────────────────────────
// Formatting helpers
// ──────────────────────────────────────────────────────────

/** Format ticks into M:SS.mmm string. Returns '--:--.---' if ticks <= 0. */
function formatTime(ticks: number): string {
  if (ticks <= 0) return '--:--.---';
  const totalMs = Math.floor((ticks / 60) * 1000);
  const ms  = totalMs % 1000;
  const sec = Math.floor(totalMs / 1000) % 60;
  const min = Math.floor(totalMs / 60000);
  return `${min}:${String(sec).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
}

// ──────────────────────────────────────────────────────────
// HudRenderer
// ──────────────────────────────────────────────────────────

export class HudRenderer {
  private container: Container;

  // Speedometer (bottom-left, HUD-01)
  private speedBarBg!: Graphics;
  private speedBarFill!: Graphics;
  private speedBarX = 0;
  private speedBarY = 0;

  // Lap counter (top-left, HUD-04)
  private lapCounterText!: Text;
  private lastLapDisplay = '';

  // Lap times (top-right, HUD-02 + HUD-03)
  private currentLapText!: Text;
  private bestLapText!: Text;
  private lastCurrentLapDisplay = '';
  private lastBestLapDisplay = '';
  private lapFlashTimer = 0; // Ticks remaining for green flash

  // Minimap (bottom-right, HUD-05)
  private minimapGraphics!: Graphics;
  private minimapOffsetX = 0;
  private minimapOffsetY = 0;
  private trackOutlineBuilt = false;
  private minimapTrackGraphics!: Graphics; // Static track outline, rebuilt once

  // Screen dimensions (updated on each render for responsiveness)
  private screenW = window.innerWidth;
  private screenH = window.innerHeight;

  constructor(hudContainer: Container) {
    this.container = hudContainer;
    this.buildHud();
  }

  /** Build all static HUD elements and add to container. */
  private buildHud(): void {
    this.buildSpeedometer();
    this.buildLapCounter();
    this.buildLapTimes();
    this.buildMinimap();
  }

  // ──────────────────────────────────────────────────────
  // Speedometer (HUD-01) — bottom-left, vertical bar fill
  // ──────────────────────────────────────────────────────

  private buildSpeedometer(): void {
    const x = MARGIN;
    const y = this.screenH - MARGIN - SPEED_BAR_H - 24; // 24px for label

    this.speedBarX = x;
    this.speedBarY = y;

    // Panel background
    const panel = new Graphics();
    panel.rect(x - 6, y - 6, SPEED_BAR_W + 12, SPEED_BAR_H + 36).fill({ color: 0x000000, alpha: PANEL_ALPHA });
    this.container.addChild(panel);

    // Bar background track
    this.speedBarBg = new Graphics();
    this.speedBarBg.rect(x, y, SPEED_BAR_W, SPEED_BAR_H).fill(0x222222);
    this.container.addChild(this.speedBarBg);

    // Bar fill (updated each frame)
    this.speedBarFill = new Graphics();
    this.container.addChild(this.speedBarFill);

    // "SPD" label below bar
    const label = new Text({ text: 'SPD', style: HUD_TEXT_STYLE_SMALL });
    label.x = x + SPEED_BAR_W / 2 - label.width / 2;
    label.y = y + SPEED_BAR_H + 6;
    this.container.addChild(label);
  }

  private updateSpeedometer(speed: number): void {
    const fill = Math.max(0, Math.min(1, speed / CAR.maxSpeed));
    const fillH = Math.floor(SPEED_BAR_H * fill);
    const x = this.speedBarX;
    const y = this.speedBarY;

    this.speedBarFill.clear();
    if (fillH > 0) {
      // Bar grows from bottom up
      this.speedBarFill
        .rect(x, y + SPEED_BAR_H - fillH, SPEED_BAR_W, fillH)
        .fill(SPEED_BAR_COLOR);
    }
  }

  // ──────────────────────────────────────────────────────
  // Lap Counter (HUD-04) — top-left
  // ──────────────────────────────────────────────────────

  private buildLapCounter(): void {
    const x = MARGIN;
    const y = MARGIN;

    const panel = new Graphics();
    panel.rect(x - 4, y - 4, 90, 30).fill({ color: 0x000000, alpha: PANEL_ALPHA });
    this.container.addChild(panel);

    this.lapCounterText = new Text({ text: 'LAP 1', style: { ...HUD_TEXT_STYLE, fontSize: 16 } });
    this.lapCounterText.x = x;
    this.lapCounterText.y = y;
    this.container.addChild(this.lapCounterText);
  }

  private updateLapCounter(currentLap: number): void {
    const display = `LAP ${currentLap}`;
    if (this.lastLapDisplay !== display) {
      this.lastLapDisplay = display;
      this.lapCounterText.text = display;
    }
  }

  // ──────────────────────────────────────────────────────
  // Lap Times (HUD-02 + HUD-03) — top-right
  // ──────────────────────────────────────────────────────

  private buildLapTimes(): void {
    // Position from right edge — use placeholder width, will reposition on first render
    const x = this.screenW - MARGIN - 160;
    const y = MARGIN;

    const panel = new Graphics();
    panel.name = 'time-panel';
    panel.rect(x - 4, y - 4, 168, 58).fill({ color: 0x000000, alpha: PANEL_ALPHA });
    this.container.addChild(panel);

    // Current lap time (larger)
    this.currentLapText = new Text({
      text: '0:00.000',
      style: { ...HUD_TEXT_STYLE, fontSize: 18 },
    });
    this.currentLapText.x = x;
    this.currentLapText.y = y;
    this.container.addChild(this.currentLapText);

    // Best lap time (smaller, below)
    this.bestLapText = new Text({
      text: 'Best: --:--.---',
      style: HUD_TEXT_STYLE_SMALL,
    });
    this.bestLapText.x = x;
    this.bestLapText.y = y + 26;
    this.container.addChild(this.bestLapText);
  }

  private updateLapTimes(currentLapTicks: number, bestLapTicks: number, lapComplete: boolean, isNewBest: boolean): void {
    // Current lap time
    const currentDisplay = formatTime(currentLapTicks);
    if (this.lastCurrentLapDisplay !== currentDisplay) {
      this.lastCurrentLapDisplay = currentDisplay;
      this.currentLapText.text = currentDisplay;
    }

    // Best lap time — always visible (HUD-03)
    const bestDisplay = `Best: ${formatTime(bestLapTicks)}`;
    if (this.lastBestLapDisplay !== bestDisplay) {
      this.lastBestLapDisplay = bestDisplay;
      this.bestLapText.text = bestDisplay;
    }

    // Green flash on new best lap (CONTEXT.md locked decision)
    if (lapComplete && isNewBest) {
      this.lapFlashTimer = 90; // 1.5s flash (90 ticks)
    }
    if (this.lapFlashTimer > 0) {
      this.lapFlashTimer--;
      this.currentLapText.style.fill = '#44ff88'; // Green flash
    } else {
      this.currentLapText.style.fill = '#ffffff'; // Normal white
    }
  }

  // ──────────────────────────────────────────────────────
  // Minimap (HUD-05) — bottom-right
  // ──────────────────────────────────────────────────────

  private buildMinimap(): void {
    this.minimapOffsetX = this.screenW - MARGIN - MINIMAP_SIZE;
    this.minimapOffsetY = this.screenH - MARGIN - MINIMAP_SIZE;

    // Panel background
    const panel = new Graphics();
    panel.rect(
      this.minimapOffsetX - 6,
      this.minimapOffsetY - 6,
      MINIMAP_SIZE + 12,
      MINIMAP_SIZE + 12,
    ).fill({ color: 0x000000, alpha: PANEL_ALPHA });
    this.container.addChild(panel);

    // Static track outline (built once on first render)
    this.minimapTrackGraphics = new Graphics();
    this.container.addChild(this.minimapTrackGraphics);

    // Dynamic car dot (redrawn every frame)
    this.minimapGraphics = new Graphics();
    this.container.addChild(this.minimapGraphics);
  }

  /**
   * Compute the minimap anchor offset so the track is centered in the minimap area.
   * The track spans roughly -200 to +200 in world space (track01 extents).
   * We compute the bounding box of outerBoundary to center correctly.
   */
  private computeMinimapTransform(outerBoundary: readonly { x: number; y: number }[]): { cx: number; cy: number } {
    if (outerBoundary.length === 0) return { cx: 0, cy: 0 };
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of outerBoundary) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return {
      cx: (minX + maxX) / 2,
      cy: (minY + maxY) / 2,
    };
  }

  private buildMinimapTrack(outerBoundary: readonly { x: number; y: number }[]): void {
    if (this.trackOutlineBuilt) return;
    this.trackOutlineBuilt = true;

    const { cx, cy } = this.computeMinimapTransform(outerBoundary);
    const ox = this.minimapOffsetX + MINIMAP_SIZE / 2;
    const oy = this.minimapOffsetY + MINIMAP_SIZE / 2;

    const pts: number[] = [];
    for (const p of outerBoundary) {
      pts.push(
        ox + (p.x - cx) * MINIMAP_SCALE,
        oy - (p.y - cy) * MINIMAP_SCALE, // Flip Y (engine Y-up → screen Y-down)
      );
    }

    this.minimapTrackGraphics.clear();
    this.minimapTrackGraphics.poly(pts).stroke({ width: 1, color: MINIMAP_TRACK_COLOR });
  }

  private updateMinimap(
    outerBoundary: readonly { x: number; y: number }[],
    carX: number,
    carY: number,
  ): void {
    // Build track outline once
    this.buildMinimapTrack(outerBoundary);

    // Recompute center for car dot positioning
    const { cx, cy } = this.computeMinimapTransform(outerBoundary);
    const ox = this.minimapOffsetX + MINIMAP_SIZE / 2;
    const oy = this.minimapOffsetY + MINIMAP_SIZE / 2;

    const dotX = ox + (carX - cx) * MINIMAP_SCALE;
    const dotY = oy - (carY - cy) * MINIMAP_SCALE; // Flip Y

    this.minimapGraphics.clear();
    this.minimapGraphics.circle(dotX, dotY, MINIMAP_DOT).fill(MINIMAP_CAR_COLOR);
  }

  // ──────────────────────────────────────────────────────
  // Main render — called every animation frame
  // ──────────────────────────────────────────────────────

  /**
   * Update all HUD elements from current world state.
   * Uses curr (not interpolated) for game state values — timing data is tick-accurate.
   * Uses curr.car.speed for speedometer (slight jitter acceptable, gameplay accurate).
   */
  render(
    _prev: WorldState,
    curr: WorldState,
    _alpha: number,
    _race: RaceState,
  ): void {
    const { car, timing, track } = curr;

    // HUD-01: Speedometer
    this.updateSpeedometer(car.speed);

    // HUD-02 + HUD-03: Lap times
    const prevBest = _prev.timing.bestLapTicks;
    const currBest = timing.bestLapTicks;
    const isNewBest = timing.lapComplete && currBest !== prevBest && currBest > 0;
    this.updateLapTimes(timing.currentLapTicks, timing.bestLapTicks, timing.lapComplete, isNewBest);

    // HUD-04: Lap counter
    this.updateLapCounter(timing.currentLap);

    // HUD-05: Minimap
    this.updateMinimap(track.outerBoundary, car.position.x, car.position.y);
  }
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "HudRenderer" | head -10 || echo "No HudRenderer errors"</automated>
  </verify>
  <done>
    HudRenderer.ts exports HudRenderer class.
    Constructor accepts hudContainer and builds all 5 HUD elements.
    render() method signature matches RenderCallback pattern.
    TypeScript compiles without errors for this file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire HudRenderer into RendererApp</name>
  <files>
    src/renderer/RendererApp.ts
  </files>
  <action>
Update RendererApp.ts to wire HudRenderer. This plan runs in Wave 2 parallel with Plan 02 (WorldRenderer). Both plans modify RendererApp.ts — but they add to DIFFERENT sections (Plan 02 adds WorldRenderer wiring, this plan adds HudRenderer wiring). To avoid merge conflicts, both plans should be executed sequentially or the executor should merge both sets of changes carefully.

Changes to make to RendererApp.ts:

1. Add import at the top:
   ```typescript
   import { HudRenderer } from './HudRenderer';
   ```

2. Add private field:
   ```typescript
   private hudRenderer!: HudRenderer;
   ```

3. In `init()`, after `this.gameLoop = new GameLoop();` and after wiring WorldRenderer (from Plan 02), add:
   ```typescript
   this.hudRenderer = new HudRenderer(this.hudContainer);
   this.gameLoop.onRender((prev, curr, alpha, race) => {
     this.hudRenderer.render(prev, curr, alpha, race);
   });
   ```

**IMPORTANT:** If Plan 02 has already been executed and added WorldRenderer wiring, carefully merge this addition without removing Plan 02's changes. Both onRender callbacks register independently — multiple callbacks are supported by GameLoop.

If executing this plan before Plan 02, add both imports and both wiring blocks. If Plan 02 already ran, add only the HudRenderer-specific lines.

The final init() method should register two onRender callbacks:
- One for WorldRenderer (from Plan 02)
- One for HudRenderer (from this plan, Plan 03)
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "type errors found" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    RendererApp.ts imports and instantiates HudRenderer with hudContainer.
    HudRenderer.render is registered as a second onRender callback in GameLoop.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    All 5 HUD elements: speedometer vertical bar (bottom-left), current lap time (top-right),
    best lap time with dashes before first lap (top-right below current), lap counter (top-left),
    minimap with track outline + yellow car dot (bottom-right).
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev`, open http://localhost:5173
    2. Confirm speedometer bar appears at bottom-left — check it fills as you accelerate
    3. Confirm lap counter shows "LAP 1" at top-left
    4. Confirm current lap time counts up in top-right (format: M:SS.mmm)
    5. Confirm best lap shows "Best: --:--.---" before any lap completion
    6. Confirm minimap at bottom-right shows track outline (thin line) and yellow car dot moving
    7. Complete a lap — confirm best lap time populates, lap counter increments, new best flashes green
    8. All HUD elements have dark semi-transparent panel backgrounds
  </how-to-verify>
  <resume-signal>Type "approved" when HUD is correct, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. All 5 HUD elements visible in browser
3. Speedometer responds to speed changes
4. Lap timer counts up and best lap populates after first completion
5. Minimap car dot tracks car position
6. Green flash on new best lap
7. Text values cache correctly (no per-frame .text assignment when value unchanged)
</verification>

<success_criteria>
- HUD-01: Speedometer vertical bar fill scales with car.speed / CAR.maxSpeed
- HUD-02: Current lap time displays as M:SS.mmm, updates each frame
- HUD-03: Best lap always visible — dashes before first lap, time after
- HUD-04: Lap counter as 'LAP X', updates on lap completion
- HUD-05: Minimap shows track outline (outer boundary) + yellow car position dot
- Lap time flashes green on new personal best (CONTEXT.md locked decision)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pixijs-renderer-playable-game/02-03-SUMMARY.md`
</output>
