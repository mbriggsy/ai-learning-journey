---
phase: 02-pixijs-renderer-playable-game
plan: 04
type: execute
wave: 3
depends_on: [02-01, 02-02, 02-03]
files_modified:
  - src/renderer/OverlayRenderer.ts
  - src/renderer/RendererApp.ts
  - src/renderer/GameLoop.ts
autonomous: true
requirements: [MECH-12, MECH-13, UX-01, UX-02]

must_haves:
  truths:
    - "On initial page load, countdown sequence shows 3... 2... 1... GO with 1-second intervals — car is visible behind it"
    - "Countdown only plays on first load — R-key instant restart skips countdown and goes directly to Racing"
    - "After 5 seconds of near-zero velocity, car fades to black and respawns at the last crossed checkpoint"
    - "Respawn: half-second fade-to-black, car appears at last checkpoint facing forward, immediate control"
    - "Escape key opens a pause overlay showing 'PAUSED' and 'Press ESC to Resume' — game is frozen"
    - "Pressing Escape again resumes — overlay disappears, game continues"
    - "R key at any time (Racing or Paused) resets the world immediately with no countdown"
    - "Lap completion shows a brief center-screen 'Lap N' overlay that fades out in ~1 second"
  artifacts:
    - path: "src/renderer/OverlayRenderer.ts"
      provides: "Countdown, pause, respawn fade, and lap-complete overlays"
  key_links:
    - from: "src/renderer/OverlayRenderer.ts"
      to: "src/renderer/GameState.ts"
      via: "reads GamePhase and countdownBeat to show correct overlay"
    - from: "src/renderer/GameLoop.ts"
      to: "src/renderer/GameState.ts"
      via: "state machine drives phase transitions detected by OverlayRenderer"
    - from: "src/renderer/RendererApp.ts"
      to: "src/renderer/OverlayRenderer.ts"
      via: "gameLoop.onRender — OverlayRenderer.render(prev, curr, alpha, race)"
---

<objective>
Implement the countdown start sequence, respawn mechanic, pause menu, and lap-complete overlay. All use the GameLoop state machine from Plan 01, which already handles state transitions. This plan adds the visual overlays that render those states.

Purpose: These UX mechanics transform the engine from a technical demo into a playable game. Without countdown, pause, and respawn, the experience is broken — the car spawns with no warning and gets permanently stuck on walls.

Output: OverlayRenderer class managing 4 overlay types (countdown, pause, respawn fade, lap complete), wired into the render loop.
</objective>

<execution_context>
@~/.claude/commands/gsd/workflows/execute-plan.md
@~/.claude/commands/gsd/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-pixijs-renderer-playable-game/02-01-SUMMARY.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key contracts from Plan 01. No codebase exploration needed. -->

From src/renderer/GameState.ts (Plan 01 output):
```typescript
export const enum GamePhase {
  Loading    = 'loading',
  Countdown  = 'countdown',
  Racing     = 'racing',
  Paused     = 'paused',
  Respawning = 'respawning',
}

export interface RaceState {
  phase: GamePhase;
  countdownBeat: number;       // 3, 2, 1, 0=GO. -1 = not in countdown
  countdownTicksLeft: number;  // Ticks until next beat (0-60)
  stuckTicks: number;          // Ticks of near-zero velocity
  respawnTicksLeft: number;    // Ticks remaining in respawn fade (0-30)
  initialLoad: boolean;
}
```

From src/renderer/GameLoop.ts (Plan 01 output):
```typescript
export type RenderCallback = (prev: WorldState, curr: WorldState, alpha: number, race: RaceState) => void;
export class GameLoop {
  onRender(cb: RenderCallback): void;
  resetWorld(countdown: boolean): void;
  startGame(): void;
}
```

From src/engine/types.ts:
```typescript
export interface TimingState {
  currentLap: number;
  lapComplete: boolean;   // true ONLY on the tick a lap finishes
  bestLapTicks: number;
}
export interface WorldState { timing: TimingState; }
```

User decisions (CONTEXT.md — locked):
- Countdown: 1s beats, camera in driving position, initial load only
- Lap completion: brief center-screen overlay, ~1s fade
- Respawn: fade-to-black (0.5s), car at last checkpoint, immediate control
- Pause menu: Pause/Resume only (no quit-to-menu — main menu doesn't exist yet)
- R key: immediate restart, no countdown
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: OverlayRenderer — countdown, pause, respawn, lap-complete</name>
  <files>
    src/renderer/OverlayRenderer.ts
  </files>
  <action>
Create OverlayRenderer.ts — manages all overlay visual states. Overlays live in the HUD container (screen space, always on top).

```typescript
import { Container, Graphics, Text } from 'pixi.js';
import type { WorldState } from '../engine/types';
import { GamePhase, type RaceState } from './GameState';

// ──────────────────────────────────────────────────────────
// Layout and style constants
// ──────────────────────────────────────────────────────────

const COUNTDOWN_FONT = {
  fontFamily: 'monospace',
  fontSize: 96,
  fill: '#ffffff',
  fontWeight: 'bold',
  dropShadow: true,
} as const;

const GO_FONT = {
  fontFamily: 'monospace',
  fontSize: 96,
  fill: '#44ff88',
  fontWeight: 'bold',
  dropShadow: true,
} as const;

const PAUSE_TITLE_FONT = {
  fontFamily: 'monospace',
  fontSize: 48,
  fill: '#ffffff',
  fontWeight: 'bold',
} as const;

const PAUSE_SUB_FONT = {
  fontFamily: 'monospace',
  fontSize: 18,
  fill: '#aaaaaa',
} as const;

const LAP_FONT = {
  fontFamily: 'monospace',
  fontSize: 36,
  fill: '#ffffff',
  fontWeight: 'bold',
} as const;

const LAP_BEST_FONT = {
  fontFamily: 'monospace',
  fontSize: 22,
  fill: '#44ff88',
  fontWeight: 'bold',
} as const;

// ──────────────────────────────────────────────────────────
// OverlayRenderer
// ──────────────────────────────────────────────────────────

/**
 * Manages all full-screen and center-screen overlays.
 * Added to the HUD container — always renders on top of world.
 */
export class OverlayRenderer {
  private container: Container;

  // Countdown overlay
  private countdownContainer!: Container;
  private countdownText!: Text;

  // Pause overlay
  private pauseContainer!: Container;

  // Respawn fade — black fullscreen rect that fades in/out
  private respawnFade!: Graphics;

  // Lap complete overlay (center-screen, fades out)
  private lapCompleteContainer!: Container;
  private lapCompleteText!: Text;
  private lapCompleteBestText!: Text;
  private lapCompleteTimer = 0; // Ticks remaining (60 = 1s)

  // Track last seen lap to detect completion
  private lastSeenLap = 1;

  constructor(private hudContainer: Container) {
    this.container = new Container();
    hudContainer.addChild(this.container);
    this.buildOverlays();
  }

  private get screenW(): number { return window.innerWidth; }
  private get screenH(): number { return window.innerHeight; }

  // ──────────────────────────────────────────────────────
  // Build overlay containers
  // ──────────────────────────────────────────────────────

  private buildOverlays(): void {
    this.buildCountdown();
    this.buildPauseMenu();
    this.buildRespawnFade();
    this.buildLapComplete();
    this.hideAll();
  }

  private buildCountdown(): void {
    this.countdownContainer = new Container();
    this.countdownContainer.visible = false;

    // Semi-transparent dark overlay (lighter than full blackout — camera still visible)
    const bg = new Graphics();
    bg.name = 'countdown-bg';
    bg.rect(0, 0, this.screenW, this.screenH).fill({ color: 0x000000, alpha: 0.35 });
    this.countdownContainer.addChild(bg);

    // Countdown number (centered)
    this.countdownText = new Text({ text: '3', style: COUNTDOWN_FONT });
    this.countdownText.anchor.set(0.5);
    this.countdownText.x = this.screenW / 2;
    this.countdownText.y = this.screenH / 2;
    this.countdownContainer.addChild(this.countdownText);

    this.container.addChild(this.countdownContainer);
  }

  private buildPauseMenu(): void {
    this.pauseContainer = new Container();
    this.pauseContainer.visible = false;

    // Dark semi-transparent backdrop
    const bg = new Graphics();
    bg.rect(0, 0, this.screenW, this.screenH).fill({ color: 0x000000, alpha: 0.6 });
    this.pauseContainer.addChild(bg);

    // "PAUSED" title
    const title = new Text({ text: 'PAUSED', style: PAUSE_TITLE_FONT });
    title.anchor.set(0.5);
    title.x = this.screenW / 2;
    title.y = this.screenH / 2 - 30;
    this.pauseContainer.addChild(title);

    // Resume instruction
    const sub = new Text({ text: 'Press ESC to Resume', style: PAUSE_SUB_FONT });
    sub.anchor.set(0.5);
    sub.x = this.screenW / 2;
    sub.y = this.screenH / 2 + 30;
    this.pauseContainer.addChild(sub);

    // Restart instruction
    const restart = new Text({ text: 'Press R to Restart', style: PAUSE_SUB_FONT });
    restart.anchor.set(0.5);
    restart.x = this.screenW / 2;
    restart.y = this.screenH / 2 + 58;
    this.pauseContainer.addChild(restart);

    this.container.addChild(this.pauseContainer);
  }

  private buildRespawnFade(): void {
    // Full-screen black rect — alpha controlled for fade effect
    this.respawnFade = new Graphics();
    this.respawnFade.rect(0, 0, this.screenW, this.screenH).fill(0x000000);
    this.respawnFade.alpha = 0;
    this.respawnFade.visible = false;
    this.container.addChild(this.respawnFade);
  }

  private buildLapComplete(): void {
    this.lapCompleteContainer = new Container();
    this.lapCompleteContainer.visible = false;

    // Lap number text
    this.lapCompleteText = new Text({ text: 'Lap 2', style: LAP_FONT });
    this.lapCompleteText.anchor.set(0.5);
    this.lapCompleteText.x = this.screenW / 2;
    this.lapCompleteText.y = this.screenH / 2 - 20;
    this.lapCompleteContainer.addChild(this.lapCompleteText);

    // "New Best!" text (hidden unless new best)
    this.lapCompleteBestText = new Text({ text: 'New Best!', style: LAP_BEST_FONT });
    this.lapCompleteBestText.anchor.set(0.5);
    this.lapCompleteBestText.x = this.screenW / 2;
    this.lapCompleteBestText.y = this.screenH / 2 + 22;
    this.lapCompleteBestText.visible = false;
    this.lapCompleteContainer.addChild(this.lapCompleteBestText);

    this.container.addChild(this.lapCompleteContainer);
  }

  private hideAll(): void {
    this.countdownContainer.visible = false;
    this.pauseContainer.visible = false;
    this.respawnFade.visible = false;
    this.lapCompleteContainer.visible = false;
  }

  // ──────────────────────────────────────────────────────
  // Update methods for each overlay type
  // ──────────────────────────────────────────────────────

  private updateCountdown(race: RaceState): void {
    if (race.phase !== GamePhase.Countdown) {
      this.countdownContainer.visible = false;
      return;
    }
    this.countdownContainer.visible = true;

    // Update text: 3, 2, 1, GO
    if (race.countdownBeat > 0) {
      this.countdownText.text = String(race.countdownBeat);
      this.countdownText.style = { ...COUNTDOWN_FONT }; // White for numbers
    } else {
      this.countdownText.text = 'GO!';
      this.countdownText.style = { ...GO_FONT }; // Green for GO
    }

    // Pulse effect: scale based on ticks within the beat
    // countdownTicksLeft goes from 60 down to 0 within each beat
    // We want: large at start of beat (60), shrinks toward next beat (0)
    const beatProgress = 1 - race.countdownTicksLeft / 60;
    const scale = 1.2 - beatProgress * 0.2; // 1.2 → 1.0 during each beat
    this.countdownText.scale.set(scale);
  }

  private updatePause(race: RaceState): void {
    this.pauseContainer.visible = race.phase === GamePhase.Paused;
  }

  private updateRespawnFade(race: RaceState): void {
    if (race.phase !== GamePhase.Respawning) {
      // Fade out if was visible (coming back from respawn)
      if (this.respawnFade.alpha > 0) {
        this.respawnFade.alpha -= 0.05; // ~20 frames to fully clear
        if (this.respawnFade.alpha <= 0) {
          this.respawnFade.visible = false;
          this.respawnFade.alpha = 0;
        }
      }
      return;
    }

    // Fading TO black (entering respawn)
    this.respawnFade.visible = true;
    // respawnTicksLeft goes from 30 → 0 during the respawn phase
    // We want: alpha goes from 0 → 1 as respawnTicksLeft → 0
    const progress = 1 - race.respawnTicksLeft / 30;
    // Fade in sharply first half, hold at max for second half
    this.respawnFade.alpha = Math.min(1, progress * 2);
  }

  private updateLapComplete(prev: WorldState, curr: WorldState): void {
    // Detect new lap completion on the tick it happens
    if (curr.timing.lapComplete && !prev.timing.lapComplete) {
      // New lap completion this tick
      const completedLap = curr.timing.currentLap - 1; // currentLap already incremented
      const isNewBest = prev.timing.bestLapTicks <= 0 ||
        curr.timing.bestLapTicks < prev.timing.bestLapTicks;

      this.lapCompleteText.text = `Lap ${completedLap}`;
      this.lapCompleteBestText.visible = isNewBest;
      this.lapCompleteContainer.visible = true;
      this.lapCompleteContainer.alpha = 1.0;
      this.lapCompleteTimer = 90; // 1.5 seconds at 60Hz
    }

    // Fade out over time
    if (this.lapCompleteTimer > 0) {
      this.lapCompleteTimer--;
      // Start fading in the last 30 ticks (0.5s)
      if (this.lapCompleteTimer < 30) {
        this.lapCompleteContainer.alpha = this.lapCompleteTimer / 30;
      }
      if (this.lapCompleteTimer <= 0) {
        this.lapCompleteContainer.visible = false;
      }
    }
  }

  // ──────────────────────────────────────────────────────
  // Main render — called every animation frame
  // ──────────────────────────────────────────────────────

  render(prev: WorldState, curr: WorldState, _alpha: number, race: RaceState): void {
    this.updateCountdown(race);
    this.updatePause(race);
    this.updateRespawnFade(race);
    this.updateLapComplete(prev, curr);
  }
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "OverlayRenderer" | head -10 || echo "No OverlayRenderer errors"</automated>
  </verify>
  <done>
    OverlayRenderer.ts exports OverlayRenderer class.
    Constructor accepts hudContainer and builds all 4 overlays.
    render() drives all overlay state from RaceState and WorldState.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire OverlayRenderer and verify GameLoop state machine</name>
  <files>
    src/renderer/RendererApp.ts
    src/renderer/GameLoop.ts
  </files>
  <action>
**Wire OverlayRenderer into RendererApp.ts:**

Read the current RendererApp.ts (modified by Plans 02 and 03). Add:

1. Import at top:
   ```typescript
   import { OverlayRenderer } from './OverlayRenderer';
   ```

2. Private field:
   ```typescript
   private overlayRenderer!: OverlayRenderer;
   ```

3. In `init()`, after creating `this.hudRenderer` (from Plan 03), add:
   ```typescript
   this.overlayRenderer = new OverlayRenderer(this.hudContainer);
   this.gameLoop.onRender((prev, curr, alpha, race) => {
     this.overlayRenderer.render(prev, curr, alpha, race);
   });
   ```

**Audit GameLoop.ts for debounce edge cases:**

Read GameLoop.ts (from Plan 01). Check the Escape key toggle logic in `tickRacing()` and `tickPaused()`:

The current logic is `if (isKeyDown('Escape'))` which fires every tick the key is held — this will rapidly toggle pause on/off. Fix this by tracking whether Escape was already processed:

In GameLoop.ts, add a private field:
```typescript
private escapeWasDown = false;
private rWasDown = false;
```

In `tickRacing()`, replace the Escape check with:
```typescript
const escapeDown = isKeyDown('Escape');
if (escapeDown && !this.escapeWasDown) {
  rs.phase = GamePhase.Paused;
}
this.escapeWasDown = escapeDown;

const rDown = isKeyDown('KeyR');
if (rDown && !this.rWasDown) {
  this.resetWorld(false);
  this.rWasDown = rDown;
  return;
}
this.rWasDown = rDown;
```

In `tickPaused()`, replace with:
```typescript
const escapeDown = isKeyDown('Escape');
if (escapeDown && !this.escapeWasDown) {
  rs.phase = GamePhase.Racing;
}
this.escapeWasDown = escapeDown;

const rDown = isKeyDown('KeyR');
if (rDown && !this.rWasDown) {
  this.resetWorld(false);
}
this.rWasDown = rDown;
```

This ensures Escape and R fire once per keypress, not once per tick while held.

**Verify countdown beat tracking in tickCountdown():**

The countdownBeat starts at 3 and decrements to 0 (GO). When beat > 0, it shows the number. When beat === 0, it shows GO and transitions to Racing on the next beat timeout. This is already implemented in Plan 01's GameLoop — confirm the logic is correct:

```
countdownBeat=3: shows "3" for 60 ticks
countdownBeat=2: shows "2" for 60 ticks
countdownBeat=1: shows "1" for 60 ticks
countdownBeat=0: shows "GO!" for 60 ticks → transitions to Racing
```

If the existing implementation transitions to Racing when `countdownBeat` decrements below 0, the GO beat is skipped. Verify and fix: the transition to `GamePhase.Racing` should happen AFTER the GO beat completes (when beat is 0 and ticksLeft reaches 0), not when beat first reaches 0.

In `tickCountdown()`, the correct implementation:
```typescript
private tickCountdown(): void {
  const rs = this.raceState;
  rs.countdownTicksLeft--;
  if (rs.countdownTicksLeft <= 0) {
    if (rs.countdownBeat > 0) {
      rs.countdownBeat--;
      rs.countdownTicksLeft = COUNTDOWN_BEAT_TICKS;
    } else {
      // countdownBeat is 0 (was showing GO!) — now transition to Racing
      rs.phase = GamePhase.Racing;
    }
  }
}
```
This shows GO for a full beat then transitions. Confirm this matches the existing code and fix if needed.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    RendererApp.ts imports OverlayRenderer and registers its render callback.
    GameLoop.ts has debounced key detection (Escape and R fire once per press, not once per tick).
    Countdown correctly shows 3-2-1-GO with full beats before transitioning.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Countdown sequence (3-2-1-GO), pause overlay, respawn fade-to-black, lap complete center overlay.
    R-key instant restart. Escape pause/resume.
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev`, open http://localhost:5173
    2. On load: confirm "3... 2... 1... GO!" countdown with 1-second beats — camera shows track, car is visible behind countdown
    3. Drive into a wall and stay stuck — after 5 seconds, confirm fade to black → car reappears at last checkpoint facing forward
    4. Press R while driving — game resets instantly, no countdown
    5. Press Escape — "PAUSED" overlay appears, game freezes, time stops
    6. Press Escape again — game resumes, overlay disappears
    7. Complete a lap — brief center overlay shows "Lap N" and fades out in ~1-1.5 seconds
    8. Confirm R key works from paused state too (instant restart)
    9. Confirm F key toggles fullscreen
  </how-to-verify>
  <resume-signal>Type "approved" when all game flow mechanics are working, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. Countdown shows 3-2-1-GO on initial load only
3. R-key restart is instant with no countdown
4. Pause overlay freezes game, Escape resumes
5. Respawn triggers after 5s stuck, fade-to-black works, car respawns at checkpoint
6. Lap complete overlay appears briefly then fades
7. Escape and R only fire once per keypress (no rapid toggle)
</verification>

<success_criteria>
- MECH-12: Countdown 3-2-1-GO plays on initial load only, 1-second beats
- MECH-13: Respawn after 5-second stuck timeout, fade-to-black, last checkpoint position
- UX-01: R key instant restart — immediate, no countdown
- UX-02: Escape pause/resume with minimal overlay (pause/resume only, no quit-to-menu)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pixijs-renderer-playable-game/02-04-SUMMARY.md`
</output>
