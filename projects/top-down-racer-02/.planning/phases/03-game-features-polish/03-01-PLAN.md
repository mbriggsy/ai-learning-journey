---
phase: 03-game-features-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/RaceController.ts
  - src/engine/types.ts
  - src/engine/car.ts
  - src/engine/world.ts
  - src/renderer/GameLoop.ts
  - src/renderer/GameState.ts
  - src/renderer/OverlayRenderer.ts
  - src/renderer/RendererApp.ts
autonomous: true
requirements: [ARCH-01]

must_haves:
  truths:
    - "RaceController lives in src/engine/ with zero renderer/browser imports — it runs headless"
    - "GamePhase enum and RaceState interface move from src/renderer/GameState.ts to src/engine/RaceController.ts"
    - "RaceController.step(input, carSpeed, timing, track) advances the state machine and returns the updated RaceState plus an action enum (None, Reset, Respawn)"
    - "GameLoop becomes a thin shell: it calls raceController.step() instead of managing phase logic directly"
    - "All existing game behavior is preserved: countdown, pause, respawn, R-key restart, Escape toggle"
    - "src/renderer/GameState.ts is deleted — all consumers import from src/engine/RaceController.ts"
    - "CarState gains a slipAngle field (rear axle slip angle in radians) — needed by Wave 2 effects and sound plans"
  artifacts:
    - path: "src/engine/RaceController.ts"
      provides: "Headless-compatible game state machine with GamePhase, RaceState, step logic"
  key_links:
    - from: "src/renderer/GameLoop.ts"
      to: "src/engine/RaceController.ts"
      via: "GameLoop calls raceController.step() and reads raceController.state"
    - from: "src/renderer/OverlayRenderer.ts"
      to: "src/engine/RaceController.ts"
      via: "imports GamePhase and RaceState types"
---

<objective>
Extract the game state machine from the renderer layer to the engine layer, making it headless-compatible for Phase 4's AI bridge.

Problem: GameLoop.ts in src/renderer/ contains game-rule logic (phase transitions, stuck detection, respawn) that isn't rendering. GamePhase and RaceState live in src/renderer/GameState.ts. Phase 4's headless AI bridge would need to import from src/renderer/ or duplicate the state machine.

Solution: Create RaceController in src/engine/ that owns all game phase logic. GameLoop becomes a thin wrapper that passes inputs to RaceController and reads its state. The AI bridge later uses RaceController directly without importing any renderer code.

Output: src/engine/RaceController.ts with full state machine logic. GameLoop.ts reduced to input/render plumbing. src/renderer/GameState.ts deleted.
</objective>

<context>
@.planning/03-CONTEXT.md
@.planning/ROADMAP.md

<interfaces>
From src/renderer/GameState.ts (will be moved):
```typescript
export const enum GamePhase {
  Loading    = 'loading',
  Countdown  = 'countdown',
  Racing     = 'racing',
  Paused     = 'paused',
  Respawning = 'respawning',
}

export interface RaceState {
  phase: GamePhase;
  countdownBeat: number;
  countdownTicksLeft: number;
  stuckTicks: number;
  respawnTicksLeft: number;
  initialLoad: boolean;
}
```

From src/renderer/GameLoop.ts (phase logic to extract):
- tickCountdown(), tickRacing(), tickPaused(), tickRespawning()
- beginRespawn(), completeRespawn()
- resetWorld(countdown: boolean), startGame()
- Constants: COUNTDOWN_BEAT_TICKS, COUNTDOWN_BEATS, STUCK_SPEED_THRESHOLD, STUCK_TIMEOUT_TICKS, RESPAWN_FADE_TICKS

From src/engine/types.ts:
```typescript
export interface TimingState { currentLap, currentLapTicks, bestLapTicks, lapComplete, lastCheckpointIndex }
export interface TrackState { checkpoints, startPosition, startHeading, ... }
export interface WorldState { car: CarState, track: TrackState, timing: TimingState, tick: number }
```

Key constraint: RaceController must NOT import isKeyDown or getInput — input decisions stay in the renderer/caller layer. RaceController receives abstract input signals.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RaceController in src/engine/</name>
  <files>
    src/engine/RaceController.ts
  </files>
  <action>
Create `src/engine/RaceController.ts`. This moves all game-phase logic out of the renderer layer.

Design:
- RaceController receives **abstract control signals** — not raw keyboard state. The caller (GameLoop or AI bridge) decides what "pause" or "restart" means for its input context.
- step() returns an **action** the caller should take (reset world, respawn car) rather than directly mutating WorldState. This keeps the controller pure — it manages phase transitions, not world state.

```typescript
// ─────────────────────────────────────────────────────────
// Game Phase & Race State (moved from src/renderer/GameState.ts)
// ─────────────────────────────────────────────────────────

export const enum GamePhase {
  Loading    = 'loading',
  Countdown  = 'countdown',
  Racing     = 'racing',
  Paused     = 'paused',
  Respawning = 'respawning',
}

export interface RaceState {
  phase: GamePhase;
  countdownBeat: number;       // 3, 2, 1, 0=GO. -1 = not in countdown
  countdownTicksLeft: number;  // Ticks until next beat (0-60)
  stuckTicks: number;          // Ticks of near-zero velocity
  respawnTicksLeft: number;    // Ticks remaining in respawn fade
  initialLoad: boolean;
}

export function createInitialRaceState(): RaceState {
  return {
    phase: GamePhase.Loading,
    countdownBeat: COUNTDOWN_BEATS,
    countdownTicksLeft: COUNTDOWN_BEAT_TICKS,
    stuckTicks: 0,
    respawnTicksLeft: 0,
    initialLoad: true,
  };
}

// ─────────────────────────────────────────────────────────
// Constants (moved from GameLoop.ts)
// ─────────────────────────────────────────────────────────

/** Ticks per countdown beat (60 = 1 second at 60Hz) */
export const COUNTDOWN_BEAT_TICKS = 60;
/** Number of countdown beats before GO (3-2-1-GO) */
export const COUNTDOWN_BEATS = 3;
/** Speed threshold below which car is considered stuck */
export const STUCK_SPEED_THRESHOLD = 2.0;
/** Ticks of being stuck before triggering respawn (300 = 5 seconds) */
export const STUCK_TIMEOUT_TICKS = 300;
/** Ticks for the respawn fade animation (30 = 0.5 seconds) */
export const RESPAWN_FADE_TICKS = 30;

// ─────────────────────────────────────────────────────────
// Control signals — what the caller wants to do this tick
// ─────────────────────────────────────────────────────────

export interface RaceControlSignals {
  /** True on the first tick of a pause request (debounced by caller) */
  togglePause: boolean;
  /** True on the first tick of a restart request (debounced by caller) */
  restart: boolean;
}

// ─────────────────────────────────────────────────────────
// Step result — actions the caller should perform
// ─────────────────────────────────────────────────────────

export const enum RaceAction {
  /** No special action — proceed normally */
  None = 'none',
  /** Caller should reset the world (with or without countdown) */
  Reset = 'reset',
  /** Caller should reset the world without countdown */
  ResetNoCd = 'reset_no_cd',
  /** Car should respawn at last checkpoint (fade complete) */
  Respawn = 'respawn',
}

export interface StepResult {
  action: RaceAction;
}

// ─────────────────────────────────────────────────────────
// RaceController — headless game state machine
// ─────────────────────────────────────────────────────────

export class RaceController {
  private _state: RaceState = createInitialRaceState();

  get state(): Readonly<RaceState> { return this._state; }

  /**
   * Advance the state machine by one tick.
   * @param signals - Abstract control inputs (pause, restart) from the caller
   * @param carSpeed - Current car speed for stuck detection
   * @returns StepResult with action the caller should perform
   */
  step(signals: RaceControlSignals, carSpeed: number): StepResult {
    const rs = this._state;

    switch (rs.phase) {
      case GamePhase.Loading:
        return { action: RaceAction.None };

      case GamePhase.Countdown:
        return this.tickCountdown(signals);

      case GamePhase.Racing:
        return this.tickRacing(signals, carSpeed);

      case GamePhase.Paused:
        return this.tickPaused(signals);

      case GamePhase.Respawning:
        return this.tickRespawning();
    }
  }

  /** Reset the state machine. countdown=true for initial load, false for R-key. */
  reset(countdown: boolean): void {
    this._state = createInitialRaceState();
    if (countdown) {
      this._state.phase = GamePhase.Countdown;
    } else {
      this._state.phase = GamePhase.Racing;
      this._state.initialLoad = false;
    }
  }

  /** Transition from Loading to Countdown (initial page load). */
  startGame(): void {
    this.reset(true);
  }

  // ─── Phase tick handlers ───────────────────────────────

  private tickCountdown(signals: RaceControlSignals): StepResult {
    const rs = this._state;
    rs.countdownTicksLeft--;
    if (rs.countdownTicksLeft <= 0) {
      if (rs.countdownBeat > 0) {
        rs.countdownBeat--;
        rs.countdownTicksLeft = COUNTDOWN_BEAT_TICKS;
      } else {
        rs.phase = GamePhase.Racing;
      }
    }
    return { action: RaceAction.None };
  }

  private tickRacing(signals: RaceControlSignals, carSpeed: number): StepResult {
    const rs = this._state;

    // Stuck detection (MECH-13)
    if (carSpeed < STUCK_SPEED_THRESHOLD) {
      rs.stuckTicks++;
      if (rs.stuckTicks >= STUCK_TIMEOUT_TICKS) {
        rs.phase = GamePhase.Respawning;
        rs.respawnTicksLeft = RESPAWN_FADE_TICKS;
        rs.stuckTicks = 0;
        return { action: RaceAction.None };
      }
    } else {
      rs.stuckTicks = 0;
    }

    // Restart request
    if (signals.restart) {
      return { action: RaceAction.ResetNoCd };
    }

    // Pause request
    if (signals.togglePause) {
      rs.phase = GamePhase.Paused;
    }

    return { action: RaceAction.None };
  }

  private tickPaused(signals: RaceControlSignals): StepResult {
    const rs = this._state;

    // Resume on toggle pause
    if (signals.togglePause) {
      rs.phase = GamePhase.Racing;
    }

    // Restart from pause
    if (signals.restart) {
      return { action: RaceAction.ResetNoCd };
    }

    return { action: RaceAction.None };
  }

  private tickRespawning(): StepResult {
    const rs = this._state;
    rs.respawnTicksLeft--;
    if (rs.respawnTicksLeft <= 0) {
      rs.phase = GamePhase.Racing;
      return { action: RaceAction.Respawn };
    }
    return { action: RaceAction.None };
  }
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "RaceController" | head -10 || echo "No RaceController errors"</automated>
  </verify>
  <done>
    src/engine/RaceController.ts exports GamePhase, RaceState, RaceController, RaceAction, RaceControlSignals.
    Zero renderer/browser imports — fully headless-compatible.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor GameLoop to use RaceController</name>
  <files>
    src/renderer/GameLoop.ts
    src/renderer/GameState.ts
  </files>
  <action>
**Rewrite GameLoop.ts** to delegate all phase logic to RaceController:

Read the current GameLoop.ts. Replace with a thin version that:

1. Imports from `src/engine/RaceController` instead of `src/renderer/GameState`
2. Creates a `RaceController` instance
3. In `stepGame()`, builds `RaceControlSignals` from keyboard state (debounced Escape/R) and calls `raceController.step()`
4. Handles the returned `RaceAction` (reset world, respawn car)
5. Removes all extracted methods: `tickCountdown`, `tickRacing`, `tickPaused`, `tickRespawning`, `beginRespawn`
6. Keeps `completeRespawn` since it needs WorldState access (or inline it)
7. Removes the local constants that moved to RaceController

The refactored GameLoop should look roughly like:

```typescript
import { buildTrack } from '../engine/track';
import { createWorld, stepWorld } from '../engine/world';
import type { Input, WorldState } from '../engine/types';
import {
  GamePhase,
  RaceAction,
  RaceController,
  type RaceControlSignals,
  type RaceState,
  RESPAWN_FADE_TICKS,
} from '../engine/RaceController';
import { getInput, isKeyDown, ZERO_INPUT } from './InputHandler';
import { TRACK_01_CONTROL_POINTS } from '../tracks/track01';

const FIXED_DT_MS = 1000 / 60;
const DEFAULT_CHECKPOINT_COUNT = 30;

export type RenderCallback = (
  prev: WorldState,
  curr: WorldState,
  alpha: number,
  race: RaceState,
) => void;

export class GameLoop {
  private track = buildTrack(TRACK_01_CONTROL_POINTS, DEFAULT_CHECKPOINT_COUNT);
  private currState: WorldState;
  private prevState: WorldState;
  private raceController = new RaceController();
  private accumulator = 0;
  private renderCallbacks: RenderCallback[] = [];
  private escapeWasDown = false;
  private rWasDown = false;

  constructor() {
    this.currState = createWorld(this.track);
    this.prevState = this.currState;
  }

  onRender(cb: RenderCallback): void {
    this.renderCallbacks.push(cb);
  }

  tick(deltaMS: number): void {
    this.accumulator = Math.min(this.accumulator + deltaMS, 200);

    while (this.accumulator >= FIXED_DT_MS) {
      this.prevState = this.currState;
      this.currState = this.stepGame();
      this.accumulator -= FIXED_DT_MS;
    }

    const alpha = this.accumulator / FIXED_DT_MS;
    const raceState = this.raceController.state;
    for (const cb of this.renderCallbacks) {
      cb(this.prevState, this.currState, alpha, raceState);
    }
  }

  private buildSignals(): RaceControlSignals {
    const escapeDown = isKeyDown('Escape');
    const rDown = isKeyDown('KeyR');

    const signals: RaceControlSignals = {
      togglePause: escapeDown && !this.escapeWasDown,
      restart: rDown && !this.rWasDown,
    };

    this.escapeWasDown = escapeDown;
    this.rWasDown = rDown;
    return signals;
  }

  private stepGame(): WorldState {
    const signals = this.buildSignals();
    const result = this.raceController.step(signals, this.currState.car.speed);
    const phase = this.raceController.state.phase;

    // Handle actions from the controller
    switch (result.action) {
      case RaceAction.ResetNoCd:
        this.resetWorld(false);
        return this.currState;
      case RaceAction.Respawn:
        return this.completeRespawn();
      case RaceAction.Reset:
        this.resetWorld(true);
        return this.currState;
      default:
        break;
    }

    // Physics stepping based on phase
    switch (phase) {
      case GamePhase.Racing:
        return stepWorld(this.currState, getInput());
      case GamePhase.Countdown:
        return stepWorld(this.currState, ZERO_INPUT);
      case GamePhase.Paused:
      case GamePhase.Respawning:
      case GamePhase.Loading:
        return this.currState;
    }
  }

  private completeRespawn(): WorldState {
    const { timing, track } = this.currState;
    const lastIdx = timing.lastCheckpointIndex;
    let respawnPos, respawnHeading: number;

    if (lastIdx >= 0 && lastIdx < track.checkpoints.length) {
      const cp = track.checkpoints[lastIdx];
      respawnPos = cp.center;
      respawnHeading = Math.atan2(cp.direction.y, cp.direction.x);
    } else {
      respawnPos = track.startPosition;
      respawnHeading = track.startHeading;
    }

    const freshWorld = createWorld(track);
    const respawned: WorldState = {
      ...freshWorld,
      car: {
        ...freshWorld.car,
        position: respawnPos,
        heading: respawnHeading,
        velocity: { x: 0, y: 0 },
        speed: 0,
        yawRate: 0,
      },
      timing: this.currState.timing,
    };
    this.prevState = respawned;
    return respawned;
  }

  resetWorld(countdown: boolean): void {
    this.currState = createWorld(this.track);
    this.prevState = this.currState;
    this.raceController.reset(countdown);
  }

  startGame(): void {
    this.resetWorld(true);
  }

  get currentWorldState(): WorldState { return this.currState; }
  get currentRaceState(): RaceState { return this.raceController.state; }
  get trackState() { return this.track; }
}
```

**Delete src/renderer/GameState.ts** — all consumers now import from `src/engine/RaceController`.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors found" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    GameLoop.ts delegates all phase logic to RaceController.
    GameState.ts deleted.
    All phase transitions still work identically.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update renderer imports to use engine RaceController</name>
  <files>
    src/renderer/OverlayRenderer.ts
    src/renderer/HudRenderer.ts
  </files>
  <action>
Update all remaining renderer files that imported from `./GameState` to import from `../engine/RaceController` instead.

**OverlayRenderer.ts:**
Change:
```typescript
import { GamePhase, type RaceState } from './GameState';
```
To:
```typescript
import { GamePhase, type RaceState } from '../engine/RaceController';
```

**HudRenderer.ts:**
Read the file first. If it imports GamePhase or RaceState from `./GameState`, update the import path. If it doesn't import from GameState, no changes needed.

**Any other files:**
Search for any remaining imports of `./GameState` or `../renderer/GameState` across the codebase and update them.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && grep -r "GameState" src/ --include="*.ts" | grep -v "node_modules" | head -20 && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 errors, no GameState imports remain"</automated>
  </verify>
  <done>
    All renderer files import GamePhase/RaceState from src/engine/RaceController.
    No remaining imports of src/renderer/GameState.
    src/renderer/GameState.ts is deleted.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="auto">
  <name>Task 4: Expose slipAngle on CarState for Wave 2 plans</name>
  <files>
    src/engine/types.ts
    src/engine/car.ts
    src/engine/world.ts
  </files>
  <action>
The Wave 2 effects renderer and sound manager need to know how much the car is sliding. Currently, slip angle is computed locally inside `stepCar` but not exposed on CarState.

**Add `slipAngle` to CarState in types.ts:**
```typescript
export interface CarState {
  // ... existing fields ...
  /** Rear axle slip angle in radians (absolute value). 0 = no slide. */
  slipAngle: number;
}
```

**In car.ts**, update `createInitialCarState` to include `slipAngle: 0`.

**In stepCar**, the rear slip angle is already calculated. Store its absolute value in the returned CarState. Find where `slipAngleRear` (or equivalent) is computed and include `slipAngle: Math.abs(slipAngleRear)` in the return object.

**In world.ts**, if `createWorld` constructs a CarState directly, ensure `slipAngle: 0` is included.

Read the existing car.ts implementation to find the exact variable name and location.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    CarState.slipAngle exposed on every physics tick.
    createInitialCarState returns slipAngle: 0.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Game state machine (GamePhase, RaceState, phase transitions, stuck detection, respawn logic) extracted from src/renderer/ to src/engine/RaceController.ts.
    GameLoop.ts is now a thin shell delegating to RaceController.
    src/renderer/GameState.ts deleted.
    CarState.slipAngle exposed for Wave 2 effects/sound plans.
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev`, open http://localhost:5173
    2. Confirm countdown 3-2-1-GO works on initial load
    3. Drive normally — confirm controls, physics, HUD all work
    4. Press Escape — confirm pause overlay appears, game freezes
    5. Press Escape again — confirm resume
    6. Press R — confirm instant restart (no countdown)
    7. Drive into wall and stay stuck ~5 seconds — confirm respawn fade works
    8. Confirm lap completion overlay still appears after crossing finish line
    9. Run `pnpm exec tsc --noEmit` — 0 errors
    10. Verify `src/renderer/GameState.ts` no longer exists
    11. Verify `src/engine/RaceController.ts` exists and has no PixiJS imports
  </how-to-verify>
  <resume-signal>Type "approved" when all game behavior is preserved, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. `grep -r "GameState" src/ --include="*.ts"` returns nothing (file deleted, imports updated)
3. `grep -r "pixi" src/engine/RaceController.ts` returns nothing (no renderer imports)
4. All existing game behavior preserved: countdown, pause, restart, respawn, lap overlays
5. RaceController can be instantiated and stepped without any browser/DOM APIs
</verification>

<success_criteria>
- ARCH-01: Game state machine extracted from renderer to engine layer, headless-compatible
- All Phase 2 behavior preserved with zero regressions
- Clean import boundary: src/engine/ has no src/renderer/ imports
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features-polish/03-01-SUMMARY.md`
</output>

<research_insights deepened="2026-02-28" agents="architecture-strategist, typescript-reviewer, performance-oracle, pattern-recognition, frontend-races-reviewer, code-simplicity-reviewer, game-state-machine-researcher, repo-research-analyst">

## Enhancement Summary

**Key improvements:** 8 actionable refinements from 8 parallel research agents.

### RI-01: Drop StepResult wrapper — return RaceAction directly
**Source:** Code simplicity reviewer, pattern recognition
`StepResult` wraps a single field. Delete the interface and have `step()` return `RaceAction` directly. Every call site that reads `result.action` simplifies to just `result`.
**Impact:** −1 interface, simpler call sites.

### RI-02: Sample input ONCE per frame, not per accumulator sub-step
**Source:** Frontend races/timing reviewer
`buildSignals()` is called inside the `while (accumulator >= FIXED_DT_MS)` loop. JavaScript's single-threaded guarantee means key state won't change between sub-steps, so debounce works *by accident*. Make the contract explicit:
```typescript
tick(deltaMS: number): void {
  this.accumulator = Math.min(this.accumulator + deltaMS, 200);
  const signals = this.buildSignals(); // sample ONCE per frame
  while (this.accumulator >= FIXED_DT_MS) {
    this.prevState = this.currState;
    this.currState = this.stepGame(signals);
    signals.togglePause = false; // consume one-shot signals after first sub-step
    signals.restart = false;
    this.accumulator -= FIXED_DT_MS;
  }
  // ... render ...
}
```
**Impact:** Eliminates fragile implicit contract. Prevents bugs if loop ever becomes async.

### RI-03: Extract `computeRespawnState()` to engine layer
**Source:** Game state machine researcher, architecture strategist
`completeRespawn()` in GameLoop contains game-rule logic (which checkpoint, heading calculation) that the Phase 4 AI bridge also needs. Extract to `src/engine/respawn.ts`:
```typescript
export function computeRespawnState(world: WorldState): { position: Vec2; heading: number } { ... }
```
**Impact:** AI bridge reuses same respawn logic without importing renderer code.

### RI-04: Fix `respawnPos` missing type annotation
**Source:** TypeScript reviewer
`let respawnPos, respawnHeading: number;` — `respawnPos` gets type `any` because only `respawnHeading` receives the `: number` annotation. Fix: `let respawnPos: Vec2; let respawnHeading: number;`

### RI-05: Add worldGeneration counter for effects/sound reset detection
**Source:** Frontend races/timing reviewer (CRITICAL BUG fix for Plan 03-02)
The `curr.tick < prev.tick` heuristic for detecting world resets fails when multiple accumulator sub-steps consume the reset in a single frame. Add a `worldGeneration` counter to GameLoop, incremented on `resetWorld()`, and pass it to render callbacks. This prevents ghost skid marks surviving a restart. Details in Plan 03-02 RI-01.

### RI-06: Add `wallImpactSpeed` to StepResult or CarState
**Source:** Architecture strategist
Plans 03-02 and 03-03 both independently implement the same wall-collision heuristic (`speedDrop > prev.car.speed * 0.1 && prev.car.speed > 10`). This creates a duplicated, fragile detection pattern that can false-positive on hard braking. Consider exposing `wallImpactSpeed: number` from the engine's collision system (already computed in `collision.ts`) so effects and sound read a single source of truth.
**Alternative:** If engine changes are too invasive, at minimum extract the shared heuristic into a named helper function importable by both consumers.

### RI-07: Add else-if chains in tickPaused() for signal priority
**Source:** Frontend races/timing reviewer, spec flow analyzer
If `togglePause`, `restart`, and `quitToMenu` arrive on the same tick, the current code executes `togglePause` (setting phase to Racing) then returns `QuitToMenu`, creating a state inconsistency. Use else-if with priority: `restart > quitToMenu > togglePause`.

### RI-08: Add headless-compatibility source scan test
**Source:** Game state machine researcher, repo research analyst
Following the existing `determinism.test.ts` pattern, add a test that scans `RaceController.ts` source for browser globals (`window`, `document`, `pixi`, `isKeyDown`). Catches accidental renderer imports.

### Architecture Validation
- Enum+switch is the right abstraction for 5 states (not XState, not class-based State pattern)
- Flat `RaceState` struct is fine — switch to discriminated unions only if states exceed ~10
- Signal/action pattern is the recognized "pure state machine with effects" pattern
- Mutable `RaceState` behind `Readonly<RaceState>` getter is acceptable for a single-owner state machine

### References
- [Andy Matuschak — Pure State Machines with Effects](https://gist.github.com/andymatuschak/d5f0a8730ad601bcccae97e8398e25b2)
- [Game Programming Patterns — State](https://gameprogrammingpatterns.com/state.html)
- [Game Programming Patterns — Game Loop](https://gameprogrammingpatterns.com/game-loop.html)

</research_insights>
