---
phase: 03-game-features-polish
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/renderer/EffectsRenderer.ts
  - src/renderer/RendererApp.ts
autonomous: true
requirements: [VIS-03, VIS-04, VIS-07, VIS-08]

must_haves:
  truths:
    - "Skid marks appear as single wide smears where tire slip exceeds threshold — they fade out over 10-15 seconds"
    - "Checkpoint flash briefly lights up the full gate line when the car crosses it"
    - "Dust/dirt particles spray when the car contacts runoff surface — sparse, large, punchy"
    - "Spark particles spray on wall collision — bright, short-lived"
    - "All effects render in world space (move with camera), not screen space"
    - "Effects read engine state only — no mutations to WorldState"
  artifacts:
    - path: "src/renderer/EffectsRenderer.ts"
      provides: "Skid marks, checkpoint flash, dust particles, spark particles"
  key_links:
    - from: "src/renderer/EffectsRenderer.ts"
      to: "src/engine/types.ts"
      via: "reads CarState.surface, CarState.position, CarState.heading, TimingState.lastCheckpointIndex"
    - from: "src/renderer/RendererApp.ts"
      to: "src/renderer/EffectsRenderer.ts"
      via: "registered as render callback on GameLoop"
---

<objective>
Add visual effects that give the player feedback on driving dynamics: skid marks showing recent racing line, checkpoint flash confirming gate crossing, dust on runoff, sparks on wall contact.

Purpose: These effects transform driving from clinical to satisfying. Skid marks show "was I tight or wide?", particles confirm surface contact, checkpoint flash confirms gate crossing. All are read-only consumers of engine state.

Output: EffectsRenderer.ts managing all 4 effect types, wired into the render loop in world space.
</objective>

<context>
@.planning/03-CONTEXT.md
@.planning/phases/03-game-features-polish/03-01-SUMMARY.md
@.planning/ROADMAP.md

<interfaces>
From src/engine/types.ts (slipAngle added by Plan 03-01 Task 4):
```typescript
export interface CarState {
  position: Vec2;
  heading: number;
  speed: number;
  velocity: Vec2;
  yawRate: number;
  surface: Surface;
  accelLongitudinal: number;
  prevInput: SmoothedInput;
  slipAngle: number;
}

export const enum Surface { Road = 0, Runoff = 1 }

export interface TimingState {
  lastCheckpointIndex: number;
  lapComplete: boolean;
  currentLap: number;
}

export interface WorldState {
  car: CarState;
  track: TrackState;
  timing: TimingState;
  tick: number;
}
```

From src/engine/RaceController.ts (Plan 01 output):
```typescript
export const enum GamePhase { Loading, Countdown, Racing, Paused, Respawning }
export interface RaceState { phase: GamePhase; ... }
```

Design decisions (CONTEXT.md — locked):
- Skid marks: single wide smear (not two tire lines), 10-15s persistence, medium intensity
- Particles: sparse and punchy — few large bright particles that pop and fade
- Checkpoint flash: brief full-gate flash in world space
- All effects render in world container (camera-relative)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EffectsRenderer with all 4 effect systems</name>
  <files>
    src/renderer/EffectsRenderer.ts
  </files>
  <action>
Create `src/renderer/EffectsRenderer.ts` — manages all visual effects in world space.

The EffectsRenderer contains four systems:
1. **Skid marks** — trail of Graphics objects left where slip exceeds threshold
2. **Checkpoint flash** — brief highlight of the gate line
3. **Dust particles** — on runoff contact
4. **Spark particles** — on wall collision

All systems use simple PixiJS primitives (Graphics for trails/lines, Graphics circles for particles). No sprite textures needed.

```typescript
import { Container, Graphics } from 'pixi.js';
import type { WorldState, Vec2 } from '../engine/types';
import { Surface } from '../engine/types';
import { GamePhase, type RaceState } from '../engine/RaceController';

// ─────────────────────────────────────────────────────────
// Configuration
// ─────────────────────────────────────────────────────────

/** Minimum slip angle (radians) to start leaving skid marks */
const SKID_SLIP_THRESHOLD = 0.08;
/** Maximum age in ticks before skid mark is removed (~12s at 60Hz) */
const SKID_MAX_AGE = 720;
/** Maximum skid mark segments alive at once */
const SKID_MAX_SEGMENTS = 300;
/** Skid mark width in world units */
const SKID_WIDTH = 1.8;

/** Checkpoint flash duration in ticks (~0.3s) */
const FLASH_DURATION = 18;
/** Checkpoint line width */
const FLASH_LINE_WIDTH = 3;

/** Maximum particles alive at once */
const MAX_PARTICLES = 40;
/** Dust particle lifetime in ticks (~0.5s) */
const DUST_LIFETIME = 30;
/** Spark particle lifetime in ticks (~0.3s) */
const SPARK_LIFETIME = 18;

// ─────────────────────────────────────────────────────────
// Data structures
// ─────────────────────────────────────────────────────────

interface SkidSegment {
  gfx: Graphics;
  age: number;
}

interface Particle {
  gfx: Graphics;
  vx: number;
  vy: number;
  age: number;
  maxAge: number;
}

interface CheckpointFlash {
  gfx: Graphics;
  age: number;
}

// ─────────────────────────────────────────────────────────
// Simple deterministic PRNG for visual-only randomness
// (engine's PRNG is separate; this is cosmetic)
// ─────────────────────────────────────────────────────────

let seed = 12345;
function rand(): number {
  seed = (seed * 16807 + 0) % 2147483647;
  return (seed - 1) / 2147483646;
}

// ─────────────────────────────────────────────────────────
// EffectsRenderer
// ─────────────────────────────────────────────────────────

export class EffectsRenderer {
  private container: Container;

  // Skid mark system
  private skidSegments: SkidSegment[] = [];
  private lastSkidPos: Vec2 | null = null;

  // Checkpoint flash system
  private flashes: CheckpointFlash[] = [];
  private lastCheckpointIndex = -1;

  // Particle system
  private particles: Particle[] = [];

  // Track if car was on wall last tick (for spark triggering)
  private wasColliding = false;

  constructor(private worldContainer: Container) {
    this.container = new Container();
    worldContainer.addChild(this.container);
  }

  render(prev: WorldState, curr: WorldState, _alpha: number, race: RaceState): void {
    // Don't update effects during non-racing phases (except respawning — fade needs to clear)
    if (race.phase === GamePhase.Loading) return;

    // Clear all effects on world reset (new lap state, tick reset)
    if (curr.tick < prev.tick) {
      this.clearAll();
      return;
    }

    if (race.phase === GamePhase.Racing) {
      this.updateSkidMarks(curr);
      this.updateCheckpointFlash(prev, curr);
      this.spawnDust(curr);
      this.spawnSparks(prev, curr);
    }

    // Always age/fade effects (even during pause — they just don't spawn new ones)
    this.ageSkidMarks();
    this.ageParticles();
    this.ageFlashes();
  }

  // ─── Skid Marks ─────────────────────────────────────────

  private updateSkidMarks(curr: WorldState): void {
    const { car } = curr;

    if (car.slipAngle < SKID_SLIP_THRESHOLD || car.surface !== Surface.Road) {
      this.lastSkidPos = null;
      return;
    }

    const pos = car.position;

    if (this.lastSkidPos) {
      // Draw a thick line segment from last position to current
      const gfx = new Graphics();
      gfx.moveTo(this.lastSkidPos.x, this.lastSkidPos.y);
      gfx.lineTo(pos.x, pos.y);
      gfx.stroke({ width: SKID_WIDTH, color: 0x222222, alpha: 0.6 });
      this.container.addChild(gfx);
      this.skidSegments.push({ gfx, age: 0 });

      // Cull oldest if over limit
      while (this.skidSegments.length > SKID_MAX_SEGMENTS) {
        const old = this.skidSegments.shift()!;
        this.container.removeChild(old.gfx);
        old.gfx.destroy();
      }
    }

    this.lastSkidPos = { x: pos.x, y: pos.y };
  }

  private ageSkidMarks(): void {
    for (let i = this.skidSegments.length - 1; i >= 0; i--) {
      const seg = this.skidSegments[i];
      seg.age++;
      // Fade over last 30% of life
      const fadeStart = SKID_MAX_AGE * 0.7;
      if (seg.age > fadeStart) {
        seg.gfx.alpha = 1 - (seg.age - fadeStart) / (SKID_MAX_AGE - fadeStart);
      }
      if (seg.age >= SKID_MAX_AGE) {
        this.container.removeChild(seg.gfx);
        seg.gfx.destroy();
        this.skidSegments.splice(i, 1);
      }
    }
  }

  // ─── Checkpoint Flash ───────────────────────────────────

  private updateCheckpointFlash(prev: WorldState, curr: WorldState): void {
    const newIdx = curr.timing.lastCheckpointIndex;
    if (newIdx !== this.lastCheckpointIndex && newIdx >= 0) {
      // New checkpoint crossed — flash the gate
      const cp = curr.track.checkpoints[newIdx];
      if (cp) {
        const gfx = new Graphics();
        gfx.moveTo(cp.left.x, cp.left.y);
        gfx.lineTo(cp.right.x, cp.right.y);
        gfx.stroke({ width: FLASH_LINE_WIDTH, color: 0x44ff88, alpha: 0.9 });
        this.container.addChild(gfx);
        this.flashes.push({ gfx, age: 0 });
      }
      this.lastCheckpointIndex = newIdx;
    }
  }

  private ageFlashes(): void {
    for (let i = this.flashes.length - 1; i >= 0; i--) {
      const flash = this.flashes[i];
      flash.age++;
      flash.gfx.alpha = 1 - flash.age / FLASH_DURATION;
      if (flash.age >= FLASH_DURATION) {
        this.container.removeChild(flash.gfx);
        flash.gfx.destroy();
        this.flashes.splice(i, 1);
      }
    }
  }

  // ─── Dust Particles (runoff surface) ────────────────────

  private spawnDust(curr: WorldState): void {
    const { car } = curr;
    if (car.surface !== Surface.Runoff || car.speed < 5) return;

    // Spawn 1-2 particles per tick when on runoff
    const count = car.speed > 40 ? 2 : 1;
    for (let i = 0; i < count; i++) {
      if (this.particles.length >= MAX_PARTICLES) break;

      const gfx = new Graphics();
      const size = 1.5 + rand() * 2.0; // Large, punchy
      gfx.circle(0, 0, size).fill({ color: 0xbb9966, alpha: 0.7 });
      gfx.x = car.position.x + (rand() - 0.5) * 3;
      gfx.y = car.position.y + (rand() - 0.5) * 3;
      this.container.addChild(gfx);

      this.particles.push({
        gfx,
        vx: (rand() - 0.5) * 1.5,
        vy: (rand() - 0.5) * 1.5,
        age: 0,
        maxAge: DUST_LIFETIME,
      });
    }
  }

  // ─── Spark Particles (wall collision) ───────────────────

  private spawnSparks(prev: WorldState, curr: WorldState): void {
    const { car } = curr;

    // Detect wall collision: speed dropped significantly in one tick AND position changed
    // A simpler heuristic: car speed decreased by >10% in one tick while speed > 10
    const speedDrop = prev.car.speed - car.speed;
    const isColliding = speedDrop > prev.car.speed * 0.1 && prev.car.speed > 10;

    if (isColliding && !this.wasColliding) {
      // Spawn burst of sparks
      const count = Math.min(6, Math.floor(speedDrop / 5));
      for (let i = 0; i < count; i++) {
        if (this.particles.length >= MAX_PARTICLES) break;

        const gfx = new Graphics();
        const size = 0.8 + rand() * 1.2;
        gfx.circle(0, 0, size).fill({ color: 0xffcc44, alpha: 0.9 });
        gfx.x = car.position.x + (rand() - 0.5) * 2;
        gfx.y = car.position.y + (rand() - 0.5) * 2;
        this.container.addChild(gfx);

        // Sparks fly outward from car
        const angle = car.heading + Math.PI + (rand() - 0.5) * 1.5;
        const spd = 2 + rand() * 3;
        this.particles.push({
          gfx,
          vx: Math.cos(angle) * spd,
          vy: Math.sin(angle) * spd,
          age: 0,
          maxAge: SPARK_LIFETIME,
        });
      }
    }

    this.wasColliding = isColliding;
  }

  // ─── Particle aging (shared for dust + sparks) ──────────

  private ageParticles(): void {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.age++;
      p.gfx.x += p.vx;
      p.gfx.y += p.vy;
      p.vx *= 0.95; // Drag
      p.vy *= 0.95;
      p.gfx.alpha = 1 - p.age / p.maxAge;

      if (p.age >= p.maxAge) {
        this.container.removeChild(p.gfx);
        p.gfx.destroy();
        this.particles.splice(i, 1);
      }
    }
  }

  // ─── Cleanup ────────────────────────────────────────────

  private clearAll(): void {
    for (const seg of this.skidSegments) {
      this.container.removeChild(seg.gfx);
      seg.gfx.destroy();
    }
    this.skidSegments = [];
    this.lastSkidPos = null;

    for (const flash of this.flashes) {
      this.container.removeChild(flash.gfx);
      flash.gfx.destroy();
    }
    this.flashes = [];
    this.lastCheckpointIndex = -1;

    for (const p of this.particles) {
      this.container.removeChild(p.gfx);
      p.gfx.destroy();
    }
    this.particles = [];
    this.wasColliding = false;
  }
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "EffectsRenderer" | head -10 || echo "No EffectsRenderer errors"</automated>
  </verify>
  <done>
    EffectsRenderer.ts exports EffectsRenderer class with all 4 effect systems.
    All effects render in world space.
    Read-only consumer of engine state.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire EffectsRenderer into RendererApp</name>
  <files>
    src/renderer/RendererApp.ts
  </files>
  <action>
Read the current RendererApp.ts. Add:

1. Import at top:
   ```typescript
   import { EffectsRenderer } from './EffectsRenderer';
   ```

2. Private field:
   ```typescript
   private effectsRenderer!: EffectsRenderer;
   ```

3. In `init()`, after creating `this.worldRenderer` and before the HUD renderer, add:
   ```typescript
   // Step 6b2: Wire Effects renderer (VIS-03, VIS-04, VIS-07, VIS-08)
   this.effectsRenderer = new EffectsRenderer(this.worldContainer);
   this.gameLoop.onRender((prev, curr, alpha, race) => {
     this.effectsRenderer.render(prev, curr, alpha, race);
   });
   ```

The effects should render in the world container AFTER the track/car but BEFORE the HUD, so they appear behind HUD elements but on top of the track surface.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    RendererApp.ts imports and initializes EffectsRenderer in world container.
    Effects render after world renderer, before HUD.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Visual effects system: skid marks (VIS-03), checkpoint flash (VIS-04), dust particles on runoff (VIS-07), spark particles on wall contact (VIS-08).
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev`, open http://localhost:5173
    2. Drive aggressively into a corner — confirm dark skid marks appear on the road surface behind the car
    3. Skid marks should fade out after ~10-15 seconds (drive in a circle, first marks should disappear)
    4. Drive through a checkpoint — confirm brief green flash along the gate line
    5. Drive onto runoff (off-track) — confirm brown dust particles spray from the car
    6. Hit a wall at speed — confirm bright yellow spark particles burst from impact point
    7. Particles should be sparse and large (not a dense cloud)
    8. Confirm all effects are in world space (move with camera, not fixed on screen)
    9. Press R to restart — confirm all effects clear
  </how-to-verify>
  <resume-signal>Type "approved" when all visual effects are working, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. Skid marks appear during slides, fade over 10-15 seconds
3. Checkpoint gate flashes green briefly on crossing
4. Dust particles spray on runoff contact
5. Spark particles burst on wall collision
6. Effects clear on restart (R key)
7. Effects don't spawn during pause or countdown
</verification>

<success_criteria>
- VIS-03: Skid marks appear as single wide smear where tires slip, fading over 10-15 seconds
- VIS-04: Checkpoint gate line flashes briefly on crossing
- VIS-07: Dust/dirt particles spray on runoff surface contact — sparse and punchy
- VIS-08: Spark particles burst on wall collision — bright and short-lived
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features-polish/03-02-SUMMARY.md`
</output>

<research_insights deepened="2026-02-28" agents="performance-oracle, frontend-races-reviewer, typescript-reviewer, pixijs-v8-researcher, code-simplicity-reviewer, architecture-strategist, pattern-recognition">

## Enhancement Summary

**Key improvements:** 7 actionable refinements. Includes 1 CRITICAL bug fix (RI-01).

### RI-01 (CRITICAL): World reset detection via generation counter, not tick comparison
**Source:** Frontend races/timing reviewer
`curr.tick < prev.tick` to detect resets FAILS when reset + first physics step both happen within one accumulator frame:
- Sub-step 1: resetWorld() sets tick=0
- Sub-step 2: stepWorld() advances to tick=1
- Render: prev=tick0, curr=tick1 → `1 < 0` is false → `clearAll()` never fires
- Result: ghost skid marks from previous session persist

**Fix:** Add `worldGeneration: number` to GameLoop (incremented on `resetWorld()`). Pass to render callbacks. EffectsRenderer tracks `lastGeneration` and clears on mismatch.
```typescript
// In EffectsRenderer:
private lastGeneration = -1;
render(prev, curr, _alpha, race, generation): void {
  if (generation !== this.lastGeneration) {
    this.clearAll();
    this.lastGeneration = generation;
    return;
  }
  // ... normal rendering ...
}
```

### RI-02: Use shared GraphicsContext for skid marks — massive perf win
**Source:** PixiJS v8 researcher
PixiJS v8 supports `GraphicsContext` sharing: GPU geometry is computed once and reused by all Graphics instances. Each skid mark becomes just a transform + alpha on top of shared geometry.
```typescript
const skidCtx = new GraphicsContext()
  .moveTo(0, 0).lineTo(8, 0)
  .stroke({ width: SKID_WIDTH, color: 0x222222, alpha: 0.6 });

// Each skid mark reuses the same GPU geometry:
const gfx = new Graphics(skidCtx);
gfx.position.set(x, y);
gfx.rotation = heading;
```
**Impact:** 300 skid marks share 1 GPU geometry buffer instead of 300. All 300 auto-batch into ~1 draw call.

### RI-03: Object pooling — never create/destroy Graphics in hot loop
**Source:** Performance oracle, PixiJS v8 researcher
Pre-allocate all Graphics objects at init. Toggle `visible` instead of addChild/removeChild. This eliminates GC pressure that causes frame hitches.
```typescript
// Pre-warm pool at construction:
for (let i = 0; i < SKID_MAX_SEGMENTS; i++) {
  const gfx = new Graphics(skidCtx);
  gfx.visible = false;
  container.addChild(gfx);
  pool.push({ gfx, active: false, age: 0 });
}
// Acquire: find inactive, set visible=true
// Release: set visible=false, reset context
```

### RI-04: Replace Array.splice() with compaction loop
**Source:** Performance oracle, frontend races reviewer
`splice(i, 1)` in reverse-iteration aging loops is O(n) per removal, O(n²) worst case with 300 segments. Use a single compaction pass:
```typescript
let writeIdx = 0;
for (let i = 0; i < this.skidSegments.length; i++) {
  if (this.skidSegments[i].age < SKID_MAX_AGE) {
    this.skidSegments[writeIdx++] = this.skidSegments[i];
  } else {
    this.skidSegments[i].gfx.visible = false; // release to pool
  }
}
this.skidSegments.length = writeIdx;
```

### RI-05: Replace custom PRNG with Math.random()
**Source:** Code simplicity reviewer
The module-level `seed` variable and custom `rand()` function add complexity for cosmetic-only randomness. Engine determinism requires a separate PRNG; visual particles do not. `Math.random()` is correct and simpler.
**Also:** If keeping custom PRNG, move `seed` to instance field on EffectsRenderer (TypeScript reviewer).

### RI-06: Add destroy() method for cleanup
**Source:** TypeScript reviewer
EffectsRenderer has no public cleanup method. When ScreenManager transitions away from gameplay or creates a new GameLoop, there's no way to release GPU resources. Add:
```typescript
destroy(): void {
  this.clearAll();
  this.container.destroy({ children: true });
}
```

### RI-07: Consider ParticleContainer for dust/sparks
**Source:** PixiJS v8 researcher
PixiJS v8's redesigned `ParticleContainer` + `Particle` handles 1M particles at 60fps. For 40 dust/spark particles, the perf difference is marginal, but it eliminates GC entirely since Particles are pre-allocated and toggled via `visible`. Requires a tiny texture (4x4 white circle) instead of Graphics drawing.
**Trade-off:** Adds a tiny texture asset to an otherwise asset-free project. Skip for now; upgrade only if profiling shows Graphics-based particles are a bottleneck.

### Performance Budget
With shared GraphicsContext + batching: ~2-3 draw calls total for all effects (1 batch for 300 skid Graphics, 1 for particles, 1 for flash). Well within budget for 60fps at 10,000+ headless ticks/sec.

### References
- [PixiJS v8 Performance Tips](https://pixijs.com/8.x/guides/concepts/performance-tips)
- [PixiJS v8 Graphics Guide](https://pixijs.com/8.x/guides/components/scene-objects/graphics)
- [GraphicsContext API Docs](https://pixijs.download/release/docs/scene.GraphicsContext.html)

</research_insights>
