---
phase: 03-game-features-polish
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/renderer/SoundManager.ts
  - src/renderer/RendererApp.ts
autonomous: true
requirements: [SND-01, SND-02, SND-03, SND-04, SND-05]

must_haves:
  truths:
    - "Engine sound synthesized via Web Audio API — pitch rises with speed (turbocharged 4-cyl rally character)"
    - "Tire screech sound when slip angle exceeds threshold — intensity scales with slip angle"
    - "Wall impact sound on collision — short burst, proportional to speed"
    - "Countdown beeps on each beat (3-2-1) with distinct GO tone"
    - "Lap completion chime — distinct tone, different sound for new best"
    - "Priority system: engine always plays, max 3-4 simultaneous sounds"
    - "Master volume and SFX/Engine split exposed as public methods for settings screen"
  artifacts:
    - path: "src/renderer/SoundManager.ts"
      provides: "All game audio via Web Audio API synthesis"
  key_links:
    - from: "src/renderer/SoundManager.ts"
      to: "src/engine/types.ts"
      via: "reads CarState.speed, CarState.slipAngle, CarState.surface"
    - from: "src/renderer/SoundManager.ts"
      to: "src/engine/RaceController.ts"
      via: "reads RaceState.phase, RaceState.countdownBeat"
    - from: "src/renderer/RendererApp.ts"
      to: "src/renderer/SoundManager.ts"
      via: "registered as render callback on GameLoop"
---

<objective>
Implement all game audio using Web Audio API synthesis — zero audio file assets. Engine drone, tire screech, wall impact, countdown beeps, and lap chime. All sounds are synthesized procedurally from oscillators, noise buffers, and filters.

Purpose: Audio feedback transforms the driving experience. Engine pitch communicates speed without looking at the HUD. Tire screech warns of grip loss. Impact sounds punish bad lines. Countdown beeps build anticipation. Lap chime celebrates progress.

Output: SoundManager.ts with 5 synthesized sound types, priority system, and volume controls for the settings screen.
</objective>

<context>
@.planning/03-CONTEXT.md
@.planning/phases/03-game-features-polish/03-01-SUMMARY.md
@.planning/ROADMAP.md

<interfaces>
From src/engine/types.ts:
```typescript
export interface CarState {
  speed: number;
  slipAngle: number;    // Added in Plan 03-01 Task 4
  surface: Surface;
}
export const enum Surface { Road = 0, Runoff = 1 }
```

From src/engine/RaceController.ts (Plan 01):
```typescript
export const enum GamePhase { Loading, Countdown, Racing, Paused, Respawning }
export interface RaceState {
  phase: GamePhase;
  countdownBeat: number;  // 3, 2, 1, 0=GO
}
```

From src/engine/constants.ts:
```typescript
export const CAR = { maxSpeed: 160, ... };
```

Design decisions (CONTEXT.md — locked):
- Engine character: turbocharged 4-cylinder rally car
- Implementation: synthesized via Web Audio API, no samples
- Tire screech: slip-angle scaled intensity
- Sound layering: priority system, max 3-4 simultaneous
- Volume: master + SFX/Engine split (two sliders)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SoundManager with all 5 sound types</name>
  <files>
    src/renderer/SoundManager.ts
  </files>
  <action>
Create `src/renderer/SoundManager.ts` — all game audio via Web Audio API synthesis.

Architecture:
- AudioContext created lazily on first user interaction (browser autoplay policy)
- Engine sound: continuous oscillator with frequency mapped to car speed
- Tire screech: noise buffer through bandpass filter, gated by slip angle
- Wall impact: oscillator burst with frequency sweep down
- Countdown beeps: sine oscillator, short envelope
- Lap chime: sine with optional octave harmony

```typescript
import type { WorldState } from '../engine/types';
import { Surface } from '../engine/types';
import { GamePhase, type RaceState } from '../engine/RaceController';
import { CAR } from '../engine/constants';

// ─────────────────────────────────────────────────────────
// Configuration
// ─────────────────────────────────────────────────────────

/** Engine sound frequency range (Hz) */
const ENGINE_FREQ_IDLE = 80;
const ENGINE_FREQ_MAX = 380;

/** Tire screech threshold (radians of slip angle) */
const SCREECH_SLIP_THRESHOLD = 0.10;
/** Screech bandpass center frequency */
const SCREECH_FREQ = 2200;
/** Screech bandpass Q */
const SCREECH_Q = 12;

/** Countdown beep frequency (Hz) — C5 */
const BEEP_FREQ = 523.25;
/** GO tone frequency (Hz) — higher, brighter */
const GO_FREQ = 784; // G5
/** Beep duration (seconds) */
const BEEP_DURATION = 0.12;

/** Lap chime base frequency — C5 */
const CHIME_FREQ = 523.25;
/** Best lap chime frequency — E5 (major third, sounds triumphant) */
const BEST_CHIME_FREQ = 659.25;
/** Chime duration */
const CHIME_DURATION = 1.2;

// ─────────────────────────────────────────────────────────
// SoundManager
// ─────────────────────────────────────────────────────────

export class SoundManager {
  private ctx: AudioContext | null = null;

  // Master gain and category gains
  private masterGain: GainNode | null = null;
  private engineGain: GainNode | null = null;
  private sfxGain: GainNode | null = null;

  // Volume settings (0-1 range)
  private _masterVolume = 0.5;
  private _engineVolume = 0.7;
  private _sfxVolume = 0.8;

  // Engine sound nodes (persistent)
  private engineOsc: OscillatorNode | null = null;
  private engineOscGain: GainNode | null = null;

  // Tire screech nodes (persistent, gated)
  private screechSource: AudioBufferSourceNode | null = null;
  private screechGain: GainNode | null = null;
  private screechFilter: BiquadFilterNode | null = null;
  private noiseBuffer: AudioBuffer | null = null;

  // State tracking
  private lastCountdownBeat = -1;
  private lastLap = 1;
  private lastBestTicks = 0;
  private wasColliding = false;
  private initialized = false;

  // ─── Initialization ─────────────────────────────────────

  /**
   * Initialize the audio context. Must be called from a user gesture
   * (click/keydown) to satisfy browser autoplay policy.
   */
  init(): void {
    if (this.initialized) return;

    try {
      this.ctx = new AudioContext();
    } catch {
      // Web Audio not supported — fail silently
      return;
    }

    // Build gain routing: sources → category gains → master → destination
    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = this._masterVolume;
    this.masterGain.connect(this.ctx.destination);

    this.engineGain = this.ctx.createGain();
    this.engineGain.gain.value = this._engineVolume;
    this.engineGain.connect(this.masterGain);

    this.sfxGain = this.ctx.createGain();
    this.sfxGain.gain.value = this._sfxVolume;
    this.sfxGain.connect(this.masterGain);

    // Pre-generate white noise buffer (2 seconds, reused for screech)
    this.noiseBuffer = this.createNoiseBuffer(2);

    // Start persistent engine sound
    this.startEngineSound();

    // Start persistent screech (initially silent)
    this.startScreechSound();

    this.initialized = true;
  }

  // ─── Volume controls (for settings screen) ──────────────

  get masterVolume(): number { return this._masterVolume; }
  set masterVolume(v: number) {
    this._masterVolume = Math.max(0, Math.min(1, v));
    if (this.masterGain) this.masterGain.gain.value = this._masterVolume;
  }

  get engineVolume(): number { return this._engineVolume; }
  set engineVolume(v: number) {
    this._engineVolume = Math.max(0, Math.min(1, v));
    if (this.engineGain) this.engineGain.gain.value = this._engineVolume;
  }

  get sfxVolume(): number { return this._sfxVolume; }
  set sfxVolume(v: number) {
    this._sfxVolume = Math.max(0, Math.min(1, v));
    if (this.sfxGain) this.sfxGain.gain.value = this._sfxVolume;
  }

  // ─── Main update (called every render frame) ────────────

  update(prev: WorldState, curr: WorldState, _alpha: number, race: RaceState): void {
    if (!this.ctx || !this.initialized) return;

    // Resume context if suspended (browser policy)
    if (this.ctx.state === 'suspended') {
      this.ctx.resume().catch(() => {});
    }

    // Mute engine during non-racing phases
    const isActive = race.phase === GamePhase.Racing || race.phase === GamePhase.Countdown;

    // Engine pitch
    this.updateEngineSound(curr.car.speed, isActive);

    // Tire screech
    this.updateScreechSound(curr.car.slipAngle, curr.car.speed, isActive);

    // Wall impact (one-shot)
    this.detectWallImpact(prev, curr, isActive);

    // Countdown beeps
    this.updateCountdownBeeps(race);

    // Lap chime
    this.detectLapComplete(prev, curr, race);
  }

  // ─── Engine Sound ───────────────────────────────────────

  private startEngineSound(): void {
    if (!this.ctx || !this.engineGain) return;

    this.engineOscGain = this.ctx.createGain();
    this.engineOscGain.gain.value = 0;
    this.engineOscGain.connect(this.engineGain);

    // Sawtooth for rich harmonics, then we'll reduce gain to keep it from being harsh
    this.engineOsc = this.ctx.createOscillator();
    this.engineOsc.type = 'sawtooth';
    this.engineOsc.frequency.value = ENGINE_FREQ_IDLE;
    this.engineOsc.connect(this.engineOscGain);
    this.engineOsc.start();
  }

  private updateEngineSound(speed: number, isActive: boolean): void {
    if (!this.ctx || !this.engineOsc || !this.engineOscGain) return;

    const t = this.ctx.currentTime;

    if (!isActive) {
      this.engineOscGain.gain.setTargetAtTime(0, t, 0.1);
      return;
    }

    // Map speed to frequency: idle at 0, max at CAR.maxSpeed
    const speedRatio = Math.min(1, Math.abs(speed) / CAR.maxSpeed);
    const freq = ENGINE_FREQ_IDLE + (ENGINE_FREQ_MAX - ENGINE_FREQ_IDLE) * speedRatio;
    this.engineOsc.frequency.setTargetAtTime(freq, t, 0.05);

    // Volume ramps with speed (quieter at idle, louder at speed)
    const vol = 0.15 + speedRatio * 0.20;
    this.engineOscGain.gain.setTargetAtTime(vol, t, 0.05);
  }

  // ─── Tire Screech ───────────────────────────────────────

  private startScreechSound(): void {
    if (!this.ctx || !this.sfxGain || !this.noiseBuffer) return;

    this.screechFilter = this.ctx.createBiquadFilter();
    this.screechFilter.type = 'bandpass';
    this.screechFilter.frequency.value = SCREECH_FREQ;
    this.screechFilter.Q.value = SCREECH_Q;

    this.screechGain = this.ctx.createGain();
    this.screechGain.gain.value = 0;
    this.screechFilter.connect(this.screechGain);
    this.screechGain.connect(this.sfxGain);

    this.screechSource = this.ctx.createBufferSource();
    this.screechSource.buffer = this.noiseBuffer;
    this.screechSource.loop = true;
    this.screechSource.connect(this.screechFilter);
    this.screechSource.start();
  }

  private updateScreechSound(slipAngle: number, speed: number, isActive: boolean): void {
    if (!this.ctx || !this.screechGain) return;

    const t = this.ctx.currentTime;

    if (!isActive || slipAngle < SCREECH_SLIP_THRESHOLD || speed < 5) {
      this.screechGain.gain.setTargetAtTime(0, t, 0.05);
      return;
    }

    // Intensity scales with slip angle: 0 at threshold, max at ~0.5 rad
    const intensity = Math.min(1, (slipAngle - SCREECH_SLIP_THRESHOLD) / 0.4);
    const vol = intensity * 0.3;
    this.screechGain.gain.setTargetAtTime(vol, t, 0.03);
  }

  // ─── Wall Impact ────────────────────────────────────────

  private detectWallImpact(prev: WorldState, curr: WorldState, isActive: boolean): void {
    if (!isActive) return;

    const speedDrop = prev.car.speed - curr.car.speed;
    const isColliding = speedDrop > prev.car.speed * 0.1 && prev.car.speed > 10;

    if (isColliding && !this.wasColliding) {
      const intensity = Math.min(1, speedDrop / 50);
      this.playImpact(intensity);
    }

    this.wasColliding = isColliding;
  }

  private playImpact(intensity: number): void {
    if (!this.ctx || !this.sfxGain) return;

    const t = this.ctx.currentTime;
    const duration = 0.08 + intensity * 0.08;

    // Low-frequency thud oscillator
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150 + intensity * 100, t);
    osc.frequency.setTargetAtTime(60, t, duration * 0.5);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.3 + intensity * 0.3, t);
    gain.gain.exponentialRampToValueAtTime(0.00001, t + duration);

    osc.connect(gain);
    gain.connect(this.sfxGain);
    osc.start(t);
    osc.stop(t + duration + 0.01);
  }

  // ─── Countdown Beeps ────────────────────────────────────

  private updateCountdownBeeps(race: RaceState): void {
    if (race.phase !== GamePhase.Countdown) {
      this.lastCountdownBeat = -1;
      return;
    }

    if (race.countdownBeat !== this.lastCountdownBeat) {
      this.lastCountdownBeat = race.countdownBeat;

      if (race.countdownBeat > 0) {
        // 3, 2, 1 — standard beep
        this.playBeep(BEEP_FREQ, BEEP_DURATION, 0.4);
      } else {
        // GO — higher, brighter, slightly longer
        this.playBeep(GO_FREQ, BEEP_DURATION * 1.5, 0.5);
      }
    }
  }

  private playBeep(freq: number, duration: number, volume: number): void {
    if (!this.ctx || !this.sfxGain) return;

    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(volume, t + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.00001, t + duration);

    osc.connect(gain);
    gain.connect(this.sfxGain);
    osc.start(t);
    osc.stop(t + duration + 0.01);
  }

  // ─── Lap Chime ──────────────────────────────────────────

  private detectLapComplete(prev: WorldState, curr: WorldState, race: RaceState): void {
    if (race.phase !== GamePhase.Racing) return;

    if (curr.timing.lapComplete && !prev.timing.lapComplete) {
      const isNewBest = prev.timing.bestLapTicks <= 0 ||
        curr.timing.bestLapTicks < prev.timing.bestLapTicks;
      this.playChime(isNewBest);
    }
  }

  private playChime(isNewBest: boolean): void {
    if (!this.ctx || !this.sfxGain) return;

    const t = this.ctx.currentTime;
    const freq = isNewBest ? BEST_CHIME_FREQ : CHIME_FREQ;

    // Primary tone
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.4, t + 0.05);
    gain.gain.setTargetAtTime(0.15, t + 0.05, 0.3);
    gain.gain.exponentialRampToValueAtTime(0.00001, t + CHIME_DURATION);

    osc.connect(gain);
    gain.connect(this.sfxGain);
    osc.start(t);
    osc.stop(t + CHIME_DURATION + 0.01);

    // Octave harmony for new best
    if (isNewBest) {
      const osc2 = this.ctx.createOscillator();
      osc2.type = 'sine';
      osc2.frequency.value = freq * 2; // Octave up

      const gain2 = this.ctx.createGain();
      gain2.gain.setValueAtTime(0, t + 0.06);
      gain2.gain.linearRampToValueAtTime(0.2, t + 0.1);
      gain2.gain.exponentialRampToValueAtTime(0.00001, t + CHIME_DURATION * 0.8);

      osc2.connect(gain2);
      gain2.connect(this.sfxGain);
      osc2.start(t + 0.06);
      osc2.stop(t + CHIME_DURATION + 0.01);
    }
  }

  // ─── Utility ────────────────────────────────────────────

  private createNoiseBuffer(durationSec: number): AudioBuffer {
    const sampleRate = this.ctx!.sampleRate;
    const length = sampleRate * durationSec;
    const buffer = this.ctx!.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);

    // Simple PRNG for noise (deterministic but visually-only — not engine PRNG)
    let s = 42;
    for (let i = 0; i < length; i++) {
      s = (s * 16807 + 0) % 2147483647;
      data[i] = ((s - 1) / 2147483646) * 2 - 1;
    }

    return buffer;
  }
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "SoundManager" | head -10 || echo "No SoundManager errors"</automated>
  </verify>
  <done>
    SoundManager.ts exports SoundManager with all 5 sound types.
    All audio synthesized via Web Audio API — zero audio file assets.
    Volume controls exposed (masterVolume, engineVolume, sfxVolume).
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SoundManager into RendererApp with user gesture init</name>
  <files>
    src/renderer/RendererApp.ts
  </files>
  <action>
Read the current RendererApp.ts. Add:

1. Import at top:
   ```typescript
   import { SoundManager } from './SoundManager';
   ```

2. Private field:
   ```typescript
   private soundManager!: SoundManager;
   ```

3. In `init()`, create the SoundManager and initialize on first user interaction:
   ```typescript
   // Step 6e: Sound system (SND-01..05)
   this.soundManager = new SoundManager();

   // Initialize audio on first keydown (browser autoplay policy requires user gesture)
   const initAudio = () => {
     this.soundManager.init();
     window.removeEventListener('keydown', initAudio);
     window.removeEventListener('click', initAudio);
   };
   window.addEventListener('keydown', initAudio);
   window.addEventListener('click', initAudio);

   this.gameLoop.onRender((prev, curr, alpha, race) => {
     this.soundManager.update(prev, curr, alpha, race);
   });
   ```

4. Expose soundManager for the settings screen (Plan 05):
   ```typescript
   get sound(): SoundManager { return this.soundManager; }
   ```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    SoundManager wired into RendererApp with user-gesture initialization.
    Sound updates every render frame.
    SoundManager accessible via app.sound for settings screen.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full synthesized audio system: engine drone with RPM pitch, tire screech, wall impact thuds, countdown beeps, and lap completion chime.
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev`, open http://localhost:5173
    2. Press any key to start — audio should initialize on first interaction
    3. Engine sound: confirm it plays continuously, pitch rises with speed, drops at idle
    4. Accelerate hard then turn sharply — confirm tire screech during slides, louder with more slip
    5. Hit a wall at speed — confirm impact thud sound
    6. On initial load, confirm countdown beeps: beep-beep-beep-HIGHER_BEEP for 3-2-1-GO
    7. Complete a lap — confirm chime sound
    8. If possible, set a new best lap — confirm a different (richer) chime with octave harmony
    9. Sounds should NOT play during pause
    10. Sounds should feel balanced — engine is baseline, effects layer on top
  </how-to-verify>
  <resume-signal>Type "approved" when all sounds work, or describe issues with specific sounds</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. Engine sound pitch correlates with car speed
3. Tire screech triggers on meaningful slides, not tiny ones
4. Wall impact fires once per collision, not continuously
5. Countdown beeps play exactly once per beat
6. Lap chime is distinct from countdown beeps
7. No audio plays during pause phase
8. Audio starts after user gesture (no autoplay violation)
</verification>

<success_criteria>
- SND-01: Engine sound with RPM-based pitch-shift (turbocharged 4-cyl character)
- SND-02: Tire screech when slip exceeds threshold, intensity scales with slip angle
- SND-03: Wall impact sound on collision, proportional to speed
- SND-04: Countdown beeps (3-2-1-GO) with distinct GO tone
- SND-05: Lap completion chime with distinct tone for new best
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features-polish/03-03-SUMMARY.md`
</output>

<research_insights deepened="2026-02-28" agents="web-audio-researcher, frontend-races-reviewer, typescript-reviewer, code-simplicity-reviewer, architecture-strategist, spec-flow-analyzer, performance-oracle">

## Enhancement Summary

**Key improvements:** 9 actionable refinements from 7 parallel research agents.

### RI-01: Use PeriodicWave instead of raw sawtooth for engine sound
**Source:** Web Audio best practices researcher
A single sawtooth oscillator sounds thin and buzzy. `createPeriodicWave()` with custom harmonic coefficients costs the same (1 OscillatorNode) but sounds dramatically better:
```typescript
const real = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
const imag = new Float32Array([0, 1.0, 0.8, 0.4, 0.3, 0.1, 0.05, 0.02]);
const wave = ctx.createPeriodicWave(real, imag);
engineOsc.setPeriodicWave(wave);
```
**Bonus:** Add a second oscillator detuned by ~7 cents for multi-cylinder "beating" roughness, plus a sub-bass sine one octave below. Total: 3 oscillators instead of 1, far richer sound.

### RI-02: Guard AudioContext.resume() with resumeRequested flag
**Source:** Frontend races/timing reviewer
`ctx.resume()` is called every frame while `ctx.state === 'suspended'`. This spawns 60 unresolved Promises per second. Guard with a flag:
```typescript
private resumeRequested = false;
// In update():
if (this.ctx.state === 'suspended' && !this.resumeRequested) {
  this.resumeRequested = true;
  this.ctx.resume()
    .then(() => { this.resumeRequested = false; })
    .catch(() => { this.resumeRequested = false; });
}
```

### RI-03: Add destroy() and suspend()/resume() methods
**Source:** TypeScript reviewer, spec flow analyzer (CRITICAL for Plan 03-05)
When the player quits to Track Select, the GameLoop ticker stops but persistent oscillators (engine, screech) keep playing at their last gain level. The engine drone will be audible on the menu screen.
```typescript
suspend(): void {
  this.ctx?.suspend();
}
resume(): void {
  this.ctx?.resume();
}
destroy(): void {
  this.engineOsc?.stop();
  this.screechSource?.stop();
  this.ctx?.close();
}
```
ScreenManager must call `suspend()` when leaving gameplay and `resume()` when entering.

### RI-04: Remove dead `lastBestTicks` field
**Source:** TypeScript reviewer
`lastBestTicks` is declared and assigned but never meaningfully read. The best-lap detection in `detectLapComplete()` uses `prev.timing.bestLapTicks` and `curr.timing.bestLapTicks` directly. Remove the dead field.

### RI-05: Replace custom PRNG in createNoiseBuffer with Math.random()
**Source:** Code simplicity reviewer
The noise buffer is cosmetic audio — determinism is irrelevant. `Math.random()` replaces 5 lines of custom PRNG code with zero behavioral difference.

### RI-06: Use onended + disconnect() for one-shot sounds
**Source:** Web Audio best practices researcher
One-shot oscillators (beeps, impact, chime) stay connected to the audio graph after stopping. Add cleanup:
```typescript
osc.onended = () => { osc.disconnect(); gain.disconnect(); };
```
Prevents node accumulation in the audio graph over long sessions.

### RI-07: Always ramp gain over 3-10ms to prevent clicks/pops
**Source:** Web Audio best practices researcher
Ensure all one-shot sounds (beep, impact, chime) ramp from 0 with `linearRampToValueAtTime` over ~3ms on attack. The current plan does this for beeps (0.02s attack) but the impact sound uses `setValueAtTime` (instant), which may click on some browsers. Change to a 5ms linear ramp.

### RI-08: Use cancelScheduledValues before new ramps
**Source:** Web Audio best practices researcher
When `updateEngineSound()` calls `setTargetAtTime()` every frame while a previous ramp is active, discontinuities can occur. Safe pattern:
```typescript
param.cancelScheduledValues(now);
param.setValueAtTime(param.value, now); // anchor current value
param.setTargetAtTime(target, now, timeConstant);
```

### RI-09: Priority system is unnecessary
**Source:** Web Audio best practices researcher, performance oracle
The plan calls for "max 3-4 simultaneous sounds" with a priority system. With ~18 total audio nodes (3 engine + 3 screech + one-shot beeps/impacts), there is no need for priority management. Modern browsers handle hundreds of nodes. The "priority system" already emerges naturally from the architecture (persistent engine/screech + one-shot events).

### Node Budget
| Sound | Nodes | Always active? |
|---|---|---|
| Engine (enhanced) | 3 osc + 3 gain + 1 master = 7 | Yes |
| Tire screech | 1 buffer + 1 bandpass + 1 gain = 3 | Yes (gated) |
| Wall impact | 1 osc + 1 gain = 2 | One-shot |
| Countdown beep | 1 osc + 1 gain = 2 | One-shot |
| Lap chime | 2 osc + 2 gain = 4 | One-shot |
| **Total max:** | **~18** | Well within budget |

### References
- [W3C Web Audio API Specification](https://webaudio.github.io/web-audio-api/)
- [Chrome Autoplay Policy](https://developer.chrome.com/blog/autoplay)
- [The Sounds of Chrome Racer](https://web.dev/racer-sound/)
- [Web Audio: The Ugly Click](http://alemangui.github.io/ramp-to-value)
- [Paul Adenot's Web Audio Performance Notes](https://padenot.github.io/web-audio-perf/)

</research_insights>
