---
phase: 03-game-features-polish
plan: 05
type: execute
wave: 3
depends_on: [03-01, 03-02, 03-03, 03-04]
files_modified:
  - src/renderer/screens/MainMenuScreen.ts
  - src/renderer/screens/TrackSelectScreen.ts
  - src/renderer/screens/SettingsScreen.ts
  - src/renderer/ScreenManager.ts
  - src/renderer/RendererApp.ts
  - src/renderer/GameLoop.ts
  - src/renderer/OverlayRenderer.ts
  - src/main.ts
autonomous: true
requirements: [UX-03, UX-04, TRK-03]

must_haves:
  truths:
    - "Main menu shows game title and two buttons: Play and Settings — minimal centered layout with track silhouette background"
    - "Track selection screen shows 3 track thumbnails (auto-rendered minimap outlines) with player best time and gold/silver/bronze par times"
    - "Selecting a track loads it and starts the race with countdown"
    - "Settings screen has Master Volume and SFX/Engine split sliders — two sliders total"
    - "Navigation: Main Menu → Track Select → Race. Two clicks to racing."
    - "Pause menu adds 'Quit to Track Select' option — Escape → Pause → Quit goes to Track Select"
    - "Quit-to-menu goes to Track Select (not main menu) — shortest path to next race"
    - "All screens use clean monospace typography consistent with existing HUD"
  artifacts:
    - path: "src/renderer/screens/MainMenuScreen.ts"
      provides: "Main menu with title, Play/Settings buttons, track silhouette background"
    - path: "src/renderer/screens/TrackSelectScreen.ts"
      provides: "Track selection with minimap thumbnails, best times, par times"
    - path: "src/renderer/screens/SettingsScreen.ts"
      provides: "Settings with Master and SFX/Engine volume sliders"
    - path: "src/renderer/ScreenManager.ts"
      provides: "Screen state machine managing transitions between menu screens and gameplay"
  key_links:
    - from: "src/renderer/ScreenManager.ts"
      to: "src/renderer/RendererApp.ts"
      via: "ScreenManager owns the game lifecycle — starts/stops GameLoop, shows/hides screens"
    - from: "src/renderer/screens/TrackSelectScreen.ts"
      to: "src/engine/track.ts"
      via: "calls buildTrack() to generate minimap thumbnails"
    - from: "src/renderer/screens/SettingsScreen.ts"
      to: "src/renderer/SoundManager.ts"
      via: "reads/writes masterVolume, engineVolume, sfxVolume"
---

<objective>
Add the complete menu system: main menu, track selection with auto-rendered thumbnails, settings with volume sliders, and the screen transition flow. This is the final plan — after this, the game feels finished.

Navigation flow: Main Menu → Track Select → Race. Escape → Pause → Quit → Track Select. Settings accessible from Main Menu. Two clicks to racing.

Output: ScreenManager coordinating all screens + 3 screen classes + updated pause menu with Quit option.
</objective>

<context>
@.planning/03-CONTEXT.md
@.planning/phases/03-game-features-polish/03-01-SUMMARY.md
@.planning/phases/03-game-features-polish/03-03-SUMMARY.md
@.planning/phases/03-game-features-polish/03-04-SUMMARY.md
@.planning/ROADMAP.md

<interfaces>
From src/engine/track.ts:
```typescript
export function buildTrack(points: TrackControlPoint[], checkpointCount: number): TrackState;
```

Track data files:
```typescript
// src/tracks/track01.ts
export const TRACK_01_CONTROL_POINTS: TrackControlPoint[];
// src/tracks/track02.ts
export const TRACK_02_CONTROL_POINTS: TrackControlPoint[];
// src/tracks/track03.ts
export const TRACK_03_CONTROL_POINTS: TrackControlPoint[];
```

From src/renderer/SoundManager.ts (Plan 03):
```typescript
export class SoundManager {
  get masterVolume(): number;
  set masterVolume(v: number): void;
  get engineVolume(): number;
  set engineVolume(v: number): void;
  get sfxVolume(): number;
  set sfxVolume(v: number): void;
}
```

From src/engine/RaceController.ts (Plan 01):
```typescript
export const enum GamePhase { Loading, Countdown, Racing, Paused, Respawning }
```

From existing GameLoop.ts:
```typescript
export class GameLoop {
  resetWorld(countdown: boolean): void;
  startGame(): void;
  // Currently hardcodes TRACK_01 — needs to accept track selection
}
```

Design decisions (CONTEXT.md — locked):
- Main menu: minimal/centered, track silhouette background, title + Play + Settings
- Track select: auto-rendered minimap thumbnails, player best + gold/silver/bronze par times
- Settings: master volume + SFX/engine split, two sliders only
- Quit-to-menu → Track Select (not main menu)
- Pause menu: add "Quit to Track Select"
- No mode selector — only one mode until Phase 6
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create track registry with metadata</name>
  <files>
    src/tracks/registry.ts
  </files>
  <action>
Create `src/tracks/registry.ts` — a central registry of all available tracks with metadata.

```typescript
import type { TrackControlPoint } from '../engine/types';
import { TRACK_01_CONTROL_POINTS } from './track01';
import { TRACK_02_CONTROL_POINTS } from './track02';
import { TRACK_03_CONTROL_POINTS } from './track03';

export interface TrackInfo {
  id: string;
  name: string;
  description: string;
  controlPoints: TrackControlPoint[];
  /** Par times in ticks (gold/silver/bronze). Set conservatively — tuned in Phase 6 with AI data. */
  parTimes: { gold: number; silver: number; bronze: number };
}

export const TRACKS: TrackInfo[] = [
  {
    id: 'track-01',
    name: 'Circuit',
    description: 'Mixed — hairpins, sweepers, chicanes',
    controlPoints: TRACK_01_CONTROL_POINTS,
    parTimes: { gold: 2400, silver: 3000, bronze: 3600 }, // 40s / 50s / 60s
  },
  {
    id: 'track-02',
    name: 'Speedway',
    description: 'Fast — sweeping curves, high speed',
    controlPoints: TRACK_02_CONTROL_POINTS,
    parTimes: { gold: 2100, silver: 2700, bronze: 3300 }, // 35s / 45s / 55s
  },
  {
    id: 'track-03',
    name: 'Gauntlet',
    description: 'Technical — tight hairpins, precision',
    controlPoints: TRACK_03_CONTROL_POINTS,
    parTimes: { gold: 2700, silver: 3300, bronze: 4200 }, // 45s / 55s / 70s
  },
];
```

These par times are initial estimates — they'll be tuned after playtesting and replaced with AI lap times in Phase 6.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "registry" | head -5 || echo "No registry errors"</automated>
  </verify>
  <done>
    src/tracks/registry.ts exports TRACKS array and TrackInfo interface.
    All 3 tracks registered with name, description, control points, and par times.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update GameLoop to accept track selection</name>
  <files>
    src/renderer/GameLoop.ts
  </files>
  <action>
Currently GameLoop hardcodes `TRACK_01_CONTROL_POINTS`. Modify it to accept a track via its constructor or a load method.

Read the current GameLoop.ts. Change:

1. Remove the hardcoded track import and construction. Instead, accept `TrackControlPoint[]` in the constructor:
   ```typescript
   constructor(trackPoints: TrackControlPoint[]) {
     this.track = buildTrack(trackPoints, DEFAULT_CHECKPOINT_COUNT);
     this.currState = createWorld(this.track);
     this.prevState = this.currState;
   }
   ```

2. Add a `loadTrack(points: TrackControlPoint[])` method for switching tracks:
   ```typescript
   loadTrack(points: TrackControlPoint[]): void {
     this.track = buildTrack(points, DEFAULT_CHECKPOINT_COUNT);
     this.currState = createWorld(this.track);
     this.prevState = this.currState;
     this.raceController.reset(true);
   }
   ```

3. Remove the direct import of `TRACK_01_CONTROL_POINTS` from GameLoop.ts — the caller (ScreenManager/RendererApp) decides which track to use.

Update RendererApp.ts to pass a default track when constructing GameLoop (import TRACK_01 there as fallback, but the ScreenManager will override it).
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    GameLoop accepts track selection via constructor and loadTrack().
    No hardcoded track import in GameLoop.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create screen classes (MainMenu, TrackSelect, Settings)</name>
  <files>
    src/renderer/screens/MainMenuScreen.ts
    src/renderer/screens/TrackSelectScreen.ts
    src/renderer/screens/SettingsScreen.ts
  </files>
  <action>
Create `src/renderer/screens/` directory with 3 screen classes. Each screen manages a PixiJS Container that can be shown/hidden.

**Common pattern:**
Each screen is a class with:
- `container: Container` — the root container (added to stage)
- `show()` / `hide()` — visibility toggle
- An `onAction` callback to signal navigation events to the ScreenManager

**MainMenuScreen.ts:**
- Dark background
- Game title "TOP-DOWN RACER" centered, large monospace
- Track silhouette: render the default track's minimap outline as a subtle background element (use `buildTrack` + draw inner/outer boundary as thin grey lines)
- Two buttons stacked: "PLAY" and "SETTINGS"
- Buttons are PixiJS Text elements with hover/click handling via PixiJS events
- Emits: `'play'` or `'settings'` when buttons are clicked

**TrackSelectScreen.ts:**
- Title: "SELECT TRACK" at top
- 3 track cards in a row (or column on narrow screens)
- Each card contains:
  - Track name
  - Auto-rendered minimap thumbnail (draw track outline using buildTrack → boundary points)
  - Player best time (reads from localStorage, or "—" if none)
  - Par time medals: gold/silver/bronze with corresponding times
- Clicking a card emits `'select'` with the track index
- Back button → emits `'back'` (returns to main menu)

**SettingsScreen.ts:**
- Title: "SETTINGS" at top
- Two horizontal slider rows:
  - "Master Volume" with a draggable slider (PixiJS Graphics-based)
  - "SFX / Engine" with a draggable slider
- Sliders map 0-1 range to SoundManager volume properties
- Back button → emits `'back'` (returns to main menu)
- Volume values persist in localStorage

For sliders, use PixiJS pointer events (pointerdown, pointermove, pointerup) on a Graphics-drawn track/thumb.

**Implementation detail for minimap thumbnails:**
```typescript
function drawTrackThumbnail(container: Container, points: TrackControlPoint[], size: number): void {
  const track = buildTrack(points, 10); // Low checkpoint count — just need boundaries
  // Find bounding box of all boundary points
  // Scale to fit within `size` x `size` pixels
  // Draw inner and outer boundary as thin lines
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "Screen" | head -10 || echo "No Screen errors"</automated>
  </verify>
  <done>
    3 screen classes created in src/renderer/screens/.
    MainMenuScreen: title + Play/Settings buttons + track silhouette.
    TrackSelectScreen: 3 cards with minimap thumbnails, best times, par times.
    SettingsScreen: 2 volume sliders reading/writing SoundManager.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create ScreenManager and wire into RendererApp</name>
  <files>
    src/renderer/ScreenManager.ts
    src/renderer/RendererApp.ts
    src/main.ts
  </files>
  <action>
**Create ScreenManager.ts** — coordinates transitions between screens and gameplay.

States:
- `'main-menu'` — MainMenuScreen visible
- `'track-select'` — TrackSelectScreen visible
- `'settings'` — SettingsScreen visible
- `'playing'` — Gameplay (GameLoop running, screens hidden)

Transitions:
- main-menu → track-select (Play button)
- main-menu → settings (Settings button)
- track-select → playing (track card click) — loads track, starts game
- track-select → main-menu (Back button)
- settings → main-menu (Back button)
- playing → track-select (Pause → Quit to Track Select)

ScreenManager:
```typescript
export class ScreenManager {
  private state: 'main-menu' | 'track-select' | 'settings' | 'playing';
  private mainMenu: MainMenuScreen;
  private trackSelect: TrackSelectScreen;
  private settings: SettingsScreen;
  // ... GameLoop and containers are managed via RendererApp reference

  constructor(app: RendererApp) { ... }

  /** Navigate to a screen or gameplay */
  goto(target: string): void { ... }

  /** Called from gameplay when player quits to menu */
  quitToTrackSelect(): void { ... }
}
```

**Update RendererApp.ts:**
- On init, show MainMenuScreen instead of immediately starting GameLoop
- GameLoop ticker only runs when in 'playing' state
- ScreenManager manages the flow

**Update main.ts if needed** — likely unchanged since RendererApp.init() handles everything.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    ScreenManager orchestrates all screen transitions.
    Main menu shows on launch.
    Track select loads selected track and starts gameplay.
    Settings reads/writes SoundManager volumes.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update pause menu with "Quit to Track Select"</name>
  <files>
    src/renderer/OverlayRenderer.ts
    src/renderer/GameLoop.ts
    src/engine/RaceController.ts
  </files>
  <action>
The existing pause overlay shows "PAUSED" and "Press ESC to Resume". Add a third option: "Press Q to Quit to Track Select".

**OverlayRenderer.ts:**
Add a third text line in `buildPauseMenu()`:
```typescript
const quit = new Text({ text: 'Press Q — Quit to Track Select', style: PAUSE_SUB_FONT });
quit.anchor.set(0.5);
quit.x = screenW / 2;
quit.y = screenH / 2 + 86;
this.pauseContainer.addChild(quit);
```

**RaceController.ts:**
Add a `quitToMenu` signal to `RaceControlSignals`:
```typescript
export interface RaceControlSignals {
  togglePause: boolean;
  restart: boolean;
  quitToMenu: boolean;
}
```

Add a new action:
```typescript
export const enum RaceAction {
  None = 'none',
  Reset = 'reset',
  ResetNoCd = 'reset_no_cd',
  Respawn = 'respawn',
  QuitToMenu = 'quit_to_menu',
}
```

In `tickPaused()`, check for quitToMenu and return `RaceAction.QuitToMenu`.

**GameLoop.ts:**
Add Q key debouncing alongside Escape and R. In `buildSignals()`:
```typescript
const qDown = isKeyDown('KeyQ');
signals.quitToMenu = qDown && !this.qWasDown;
this.qWasDown = qDown;
```

In `stepGame()`, handle `RaceAction.QuitToMenu` by calling a callback that ScreenManager provides:
```typescript
case RaceAction.QuitToMenu:
  this.onQuitToMenu?.();
  return this.currState;
```

Add:
```typescript
onQuitToMenu: (() => void) | null = null;
```

ScreenManager sets this callback when entering gameplay mode.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep -c "error TS" && echo "TS errors" || echo "0 TypeScript errors"</automated>
  </verify>
  <done>
    Pause menu shows Quit to Track Select option.
    Q key during pause triggers navigation to track select.
    RaceController supports quitToMenu signal.
    TypeScript compiles with 0 errors.
  </done>
</task>

<task type="auto">
  <name>Task 6: Best time persistence via localStorage</name>
  <files>
    src/renderer/BestTimes.ts
  </files>
  <action>
Create a simple localStorage wrapper for persisting best lap times per track.

```typescript
const STORAGE_KEY = 'tdr-best-times';

interface BestTimesData {
  [trackId: string]: number; // Best lap time in ticks
}

function load(): BestTimesData {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

function save(data: BestTimesData): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  } catch {
    // localStorage full or unavailable — fail silently
  }
}

export function getBestTime(trackId: string): number | null {
  const data = load();
  return data[trackId] ?? null;
}

export function setBestTime(trackId: string, ticks: number): boolean {
  const data = load();
  const current = data[trackId];
  if (current === undefined || ticks < current) {
    data[trackId] = ticks;
    save(data);
    return true; // New best
  }
  return false;
}

export function formatTime(ticks: number): string {
  const totalSeconds = ticks / 60;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  if (minutes > 0) {
    return `${minutes}:${seconds.toFixed(2).padStart(5, '0')}`;
  }
  return seconds.toFixed(2) + 's';
}
```

TrackSelectScreen uses `getBestTime(trackId)` to display best times.
GameLoop (or ScreenManager) calls `setBestTime(trackId, bestLapTicks)` when a new best is achieved during gameplay.
  </action>
  <verify>
    <automated>cd "C:/Users/brigg/ai-learning-journey/projects/top-down-racer-02" && pnpm exec tsc --noEmit 2>&1 | grep "BestTimes" | head -5 || echo "No BestTimes errors"</automated>
  </verify>
  <done>
    BestTimes utility persists per-track best laps in localStorage.
    getBestTime/setBestTime/formatTime exported.
    TypeScript compiles without errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete menu system: main menu, track selection with minimap thumbnails and par times, settings with volume sliders, pause menu with Quit to Track Select, best time persistence.
  </what-built>
  <how-to-verify>
    1. Run `pnpm dev`, open http://localhost:5173
    2. **Main Menu:** Title "TOP-DOWN RACER" centered, Play and Settings buttons, track silhouette in background
    3. Click "Settings" — confirm two volume sliders (Master, SFX/Engine). Drag them, confirm sound volume changes. Click Back.
    4. Click "Play" — **Track Select:** 3 track cards with minimap thumbnails, names (Circuit, Speedway, Gauntlet), par times
    5. Best times show "—" initially
    6. Click a track card — game loads that track and starts with countdown
    7. **Drive and complete a lap** — confirm best time is saved
    8. Press Escape during race — pause overlay shows Resume, Restart, and **Quit to Track Select**
    9. Press Q — navigates to Track Select (NOT main menu)
    10. Confirm the track you raced now shows your best time
    11. Select a different track — confirm it loads a DIFFERENT layout
    12. Press R during race — instant restart on the same track
    13. Close and reopen the page — confirm best times persist
  </how-to-verify>
  <resume-signal>Type "approved" when full menu flow works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with 0 errors
2. Main menu → Track Select → Race flow works (two clicks to racing)
3. All 3 tracks selectable and load different layouts
4. Minimap thumbnails accurately represent track shapes
5. Settings volume sliders affect audio levels
6. Pause → Q → Track Select navigation works
7. Best times persist in localStorage across page reloads
8. Par times displayed on track cards
</verification>

<success_criteria>
- UX-03: Main menu with track selection (mode selection deferred to Phase 6 per CONTEXT.md)
- UX-04: Settings with master volume + SFX/engine split (two sliders)
- TRK-03: Track selection screen with minimap thumbnails and best times
- Pause menu updated with "Quit to Track Select"
- Best times persist in localStorage
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features-polish/03-05-SUMMARY.md`
</output>

<research_insights deepened="2026-02-28" agents="frontend-races-reviewer, typescript-reviewer, menu-ux-researcher, security-sentinel, pattern-recognition, spec-flow-analyzer, performance-oracle, code-simplicity-reviewer">

## Enhancement Summary

**Key improvements:** 12 actionable refinements from 8 parallel research agents. Includes 2 CRITICAL fixes.

### RI-01 (CRITICAL): Abort tick loop on QuitToMenu
**Source:** Frontend races/timing reviewer
When `onQuitToMenu` fires inside `stepGame()`, the accumulator loop continues processing dead sub-steps. ScreenManager hides gameplay and shows Track Select, but remaining sub-steps call `stepGame()` on invisible state. At worst, if `onQuitToMenu()` destroys anything, you get a runtime error.
```typescript
private abortTick = false;

// In stepGame():
case RaceAction.QuitToMenu:
  this.abortTick = true;
  this.onQuitToMenu?.();
  return this.currState;

// In tick():
while (this.accumulator >= FIXED_DT_MS) {
  if (this.abortTick) break;
  this.prevState = this.currState;
  this.currState = this.stepGame(signals);
  this.accumulator -= FIXED_DT_MS;
}
if (this.abortTick) {
  this.abortTick = false;
  this.accumulator = 0;
  return; // skip render callbacks
}
```

### RI-02 (CRITICAL): SoundManager.suspend() on screen transitions
**Source:** Spec flow analyzer
When quitting to Track Select, the GameLoop ticker stops but persistent audio nodes (engine oscillator, screech noise) keep playing at their last gain level. The engine drone will be audible on menu screens. ScreenManager must call `soundManager.suspend()` when leaving gameplay and `soundManager.resume()` when entering. See Plan 03-03 RI-03.

### RI-03: Use union type for ScreenManager state, not bare strings
**Source:** TypeScript reviewer, pattern recognition
`goto(target: string)` accepts any string. Use a union type:
```typescript
type ScreenState = 'main-menu' | 'track-select' | 'settings' | 'playing';
private state: ScreenState;
goto(target: ScreenState): void { ... }
```
**Impact:** Compile-time safety against typos like `goto('main_menu')`.

### RI-04: Pass specific deps to ScreenManager, not whole RendererApp
**Source:** Architecture strategist, code simplicity reviewer
`ScreenManager(app: RendererApp)` creates a circular dependency (RendererApp creates ScreenManager, ScreenManager needs RendererApp). Pass specific dependencies instead:
```typescript
constructor(deps: {
  stage: Container;
  gameLoop: GameLoop;
  soundManager: SoundManager;
  effectsRenderer: EffectsRenderer;
}) { ... }
```

### RI-05: Use globalpointermove for slider drag
**Source:** Menu UX researcher (prevents stuck slider)
If the pointer moves faster than the thumb, `pointermove` stops firing on the thumb element. The slider freezes mid-drag. Use `globalpointermove` (PixiJS v8):
```typescript
thumb.on('pointerdown', () => { this.dragging = true; });
thumb.on('globalpointermove', (e) => {
  if (!this.dragging) return;
  this.setValueFromX(e.getLocalPosition(this).x);
});
thumb.on('pointerup', () => { this.dragging = false; });
thumb.on('pointerupoutside', () => { this.dragging = false; });
```

### RI-06: Use cubic (x³) volume mapping for perceptually-linear sliders
**Source:** Menu UX researcher
Human hearing is logarithmic. A linear slider mapping produces most perceived volume change in the first 25% of travel. Use cubic:
```typescript
function sliderToVolume(pos: number): number { return pos * pos * pos; }
function volumeToSlider(vol: number): number { return Math.cbrt(vol); }
```
Store the **linear slider position** in localStorage, not the computed volume.

### RI-07: Validate JSON.parse in BestTimes.ts
**Source:** Security sentinel, TypeScript reviewer
`JSON.parse(raw)` in `load()` accepts any valid JSON. Validate the parsed object:
```typescript
function load(): BestTimesData {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) return {};
    // Validate each entry is a number
    const result: BestTimesData = {};
    for (const [k, v] of Object.entries(parsed)) {
      if (typeof v === 'number' && v > 0) result[k] = v;
    }
    return result;
  } catch { return {}; }
}
```

### RI-08: Add transition guard on ScreenManager
**Source:** Frontend races/timing reviewer
Guard against invalid state transitions and double-clicks:
```typescript
const VALID_TRANSITIONS: Record<ScreenState, ScreenState[]> = {
  'main-menu':    ['track-select', 'settings'],
  'track-select': ['main-menu', 'playing'],
  'settings':     ['main-menu'],
  'playing':      ['track-select'],
};
goto(target: ScreenState): void {
  if (this.state === target) return;
  if (!VALID_TRANSITIONS[this.state]?.includes(target)) return;
  // ... transition ...
}
```

### RI-09: Cache buildTrack() thumbnails
**Source:** Performance oracle
`buildTrack()` for thumbnails runs spline sampling + boundary generation. Cache the result per track since control points never change:
```typescript
const thumbnailCache = new Map<string, TrackState>();
function getTrackThumbnail(trackId: string, points: TrackControlPoint[]): TrackState {
  if (!thumbnailCache.has(trackId)) {
    thumbnailCache.set(trackId, buildTrack(points, 10));
  }
  return thumbnailCache.get(trackId)!;
}
```

### RI-10: Use eventMode='static' for all interactive elements
**Source:** PixiJS v8 docs
All buttons and sliders need `eventMode = 'static'` (v8 replacement for v7's `interactive = true`). Also set `cursor = 'pointer'` for click affordance.

### RI-11: Add Escape-as-back on menu screens
**Source:** Spec flow analyzer
No keyboard shortcuts exist for menu navigation. At minimum, Escape on Track Select should go to Main Menu, and Escape on Settings should go to Main Menu. This requires a window-level keydown listener managed per-screen.

### RI-12: Wire best-time saving with trackId
**Source:** Spec flow analyzer
GameLoop doesn't know the `trackId` string. Either:
(a) Pass `trackId` into GameLoop alongside control points, or
(b) ScreenManager monitors lap completion via a callback and calls `setBestTime()` with the trackId it knows from selection.
Option (b) is cleaner — keeps GameLoop agnostic to persistence.

### UX Recommendations
- **Track cards:** Horizontal row, large thumbnails (60% card height), scale-up on hover (2-5%)
- **Buttons:** Graphics-based with idle/hover/press fill states
- **Monospace typography:** Consistent with existing HUD style
- **No @pixi/ui dependency needed:** Pure PixiJS Graphics + Text for 2 buttons and 2 sliders

### References
- [PixiJS v8 Events & Interaction](https://pixijs.com/8.x/guides/components/events)
- [Menu UX — Game UI Database](https://www.gameuidatabase.com/index.php?tag=4)
- [Dr. Lex — Volume Controls](https://www.dr-lex.be/info-stuff/volumecontrols.html)
- [MDN — Storage Quotas](https://developer.mozilla.org/en-US/docs/Web/API/Storage_API/Storage_quotas_and_eviction_criteria)

</research_insights>
